// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: password_reset.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRecentResetRequestsByEmail = `-- name: CountRecentResetRequestsByEmail :one
SELECT COUNT(*)
FROM password_reset_tokens
WHERE user_id = $1
  AND created_at > $2
`

type CountRecentResetRequestsByEmailParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Count recent password reset requests for a specific user (rate limiting)
func (q *Queries) CountRecentResetRequestsByEmail(ctx context.Context, arg CountRecentResetRequestsByEmailParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentResetRequestsByEmail, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentResetRequestsByIP = `-- name: CountRecentResetRequestsByIP :one
SELECT COUNT(*)
FROM password_reset_tokens
WHERE ip_address = $1
  AND created_at > $2
`

type CountRecentResetRequestsByIPParams struct {
	IpAddress pgtype.Text        `json:"ip_address"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Count recent password reset requests from a specific IP address (rate limiting)
func (q *Queries) CountRecentResetRequestsByIP(ctx context.Context, arg CountRecentResetRequestsByIPParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentResetRequestsByIP, arg.IpAddress, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_reset_tokens (
    tenant_id,
    user_id,
    token_hash,
    expires_at,
    ip_address,
    user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, user_id, token_hash, used, used_at, expires_at, ip_address, user_agent, created_at
`

type CreatePasswordResetTokenParams struct {
	TenantID  pgtype.UUID        `json:"tenant_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	IpAddress pgtype.Text        `json:"ip_address"`
	UserAgent pgtype.Text        `json:"user_agent"`
}

// Create a new password reset token
func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordResetToken, error) {
	row := q.db.QueryRow(ctx, createPasswordResetToken,
		arg.TenantID,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.Used,
		&i.UsedAt,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec
DELETE FROM password_reset_tokens
WHERE expires_at <= NOW()
`

// Delete expired password reset tokens (cleanup job)
func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResetTokens)
	return err
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT
    prt.id,
    prt.tenant_id,
    prt.user_id,
    prt.token_hash,
    prt.used,
    prt.used_at,
    prt.expires_at,
    prt.created_at,
    u.email as user_email,
    u.first_name as user_first_name,
    u.last_name as user_last_name,
    u.status as user_status
FROM password_reset_tokens prt
INNER JOIN users u ON prt.user_id = u.id
WHERE prt.tenant_id = $1
  AND prt.token_hash = $2
  AND prt.used = FALSE
  AND prt.expires_at > NOW()
LIMIT 1
`

type GetPasswordResetTokenParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	TokenHash string      `json:"token_hash"`
}

type GetPasswordResetTokenRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	UserID        pgtype.UUID        `json:"user_id"`
	TokenHash     string             `json:"token_hash"`
	Used          bool               `json:"used"`
	UsedAt        pgtype.Timestamptz `json:"used_at"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UserEmail     string             `json:"user_email"`
	UserFirstName pgtype.Text        `json:"user_first_name"`
	UserLastName  pgtype.Text        `json:"user_last_name"`
	UserStatus    string             `json:"user_status"`
}

// Get a valid (unused, non-expired) password reset token with user details
func (q *Queries) GetPasswordResetToken(ctx context.Context, arg GetPasswordResetTokenParams) (GetPasswordResetTokenRow, error) {
	row := q.db.QueryRow(ctx, getPasswordResetToken, arg.TenantID, arg.TokenHash)
	var i GetPasswordResetTokenRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.Used,
		&i.UsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.UserStatus,
	)
	return i, err
}

const invalidateUserPasswordResetTokens = `-- name: InvalidateUserPasswordResetTokens :exec
UPDATE password_reset_tokens
SET
    used = TRUE,
    used_at = NOW()
WHERE tenant_id = $1
  AND user_id = $2
  AND used = FALSE
`

type InvalidateUserPasswordResetTokensParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

// Mark all unused password reset tokens for a user as used
// (Called after successful password reset to invalidate other tokens)
func (q *Queries) InvalidateUserPasswordResetTokens(ctx context.Context, arg InvalidateUserPasswordResetTokensParams) error {
	_, err := q.db.Exec(ctx, invalidateUserPasswordResetTokens, arg.TenantID, arg.UserID)
	return err
}

const markPasswordResetTokenUsed = `-- name: MarkPasswordResetTokenUsed :exec
UPDATE password_reset_tokens
SET
    used = TRUE,
    used_at = NOW()
WHERE tenant_id = $1
  AND token_hash = $2
  AND used = FALSE
`

type MarkPasswordResetTokenUsedParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	TokenHash string      `json:"token_hash"`
}

// Mark a password reset token as used
func (q *Queries) MarkPasswordResetTokenUsed(ctx context.Context, arg MarkPasswordResetTokenUsedParams) error {
	_, err := q.db.Exec(ctx, markPasswordResetTokenUsed, arg.TenantID, arg.TokenHash)
	return err
}
