// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSubscriptions = `-- name: CountSubscriptions :one
SELECT COUNT(*)
FROM subscriptions
WHERE tenant_id = $1
`

// Count total subscriptions for pagination
func (q *Queries) CountSubscriptions(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptions, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubscriptionsByStatus = `-- name: CountSubscriptionsByStatus :one
SELECT COUNT(*) FROM subscriptions
WHERE tenant_id = $1
  AND status = $2
`

type CountSubscriptionsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

// Counts subscriptions by status for pagination
func (q *Queries) CountSubscriptionsByStatus(ctx context.Context, arg CountSubscriptionsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptionsByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscription = `-- name: CreateSubscription :one

INSERT INTO subscriptions (
    tenant_id,
    user_id,
    subscription_plan_id,
    billing_interval,
    status,
    billing_customer_id,
    provider,
    provider_subscription_id,
    subtotal_cents,
    tax_cents,
    total_cents,
    currency,
    shipping_address_id,
    shipping_method_id,
    shipping_cents,
    payment_method_id,
    current_period_start,
    current_period_end,
    next_billing_date,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
)
RETURNING id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at
`

type CreateSubscriptionParams struct {
	TenantID               pgtype.UUID        `json:"tenant_id"`
	UserID                 pgtype.UUID        `json:"user_id"`
	SubscriptionPlanID     pgtype.UUID        `json:"subscription_plan_id"`
	BillingInterval        string             `json:"billing_interval"`
	Status                 string             `json:"status"`
	BillingCustomerID      pgtype.UUID        `json:"billing_customer_id"`
	Provider               string             `json:"provider"`
	ProviderSubscriptionID pgtype.Text        `json:"provider_subscription_id"`
	SubtotalCents          int32              `json:"subtotal_cents"`
	TaxCents               int32              `json:"tax_cents"`
	TotalCents             int32              `json:"total_cents"`
	Currency               string             `json:"currency"`
	ShippingAddressID      pgtype.UUID        `json:"shipping_address_id"`
	ShippingMethodID       pgtype.UUID        `json:"shipping_method_id"`
	ShippingCents          int32              `json:"shipping_cents"`
	PaymentMethodID        pgtype.UUID        `json:"payment_method_id"`
	CurrentPeriodStart     pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd       pgtype.Timestamptz `json:"current_period_end"`
	NextBillingDate        pgtype.Timestamptz `json:"next_billing_date"`
	Metadata               []byte             `json:"metadata"`
}

// Subscription queries for the SubscriptionService
// Creates a new subscription record
// Returns the complete subscription with generated ID and timestamps
func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.TenantID,
		arg.UserID,
		arg.SubscriptionPlanID,
		arg.BillingInterval,
		arg.Status,
		arg.BillingCustomerID,
		arg.Provider,
		arg.ProviderSubscriptionID,
		arg.SubtotalCents,
		arg.TaxCents,
		arg.TotalCents,
		arg.Currency,
		arg.ShippingAddressID,
		arg.ShippingMethodID,
		arg.ShippingCents,
		arg.PaymentMethodID,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.NextBillingDate,
		arg.Metadata,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscriptionItem = `-- name: CreateSubscriptionItem :one
INSERT INTO subscription_items (
    tenant_id,
    subscription_id,
    product_sku_id,
    quantity,
    unit_price_cents,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, tenant_id, subscription_id, product_sku_id, quantity, unit_price_cents, metadata, created_at, updated_at
`

type CreateSubscriptionItemParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	ProductSkuID   pgtype.UUID `json:"product_sku_id"`
	Quantity       int32       `json:"quantity"`
	UnitPriceCents int32       `json:"unit_price_cents"`
	Metadata       []byte      `json:"metadata"`
}

// Creates a subscription item (product in subscription)
// Captures pricing at time of subscription creation
func (q *Queries) CreateSubscriptionItem(ctx context.Context, arg CreateSubscriptionItemParams) (SubscriptionItem, error) {
	row := q.db.QueryRow(ctx, createSubscriptionItem,
		arg.TenantID,
		arg.SubscriptionID,
		arg.ProductSkuID,
		arg.Quantity,
		arg.UnitPriceCents,
		arg.Metadata,
	)
	var i SubscriptionItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.ProductSkuID,
		&i.Quantity,
		&i.UnitPriceCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSubscriptionScheduleEvent = `-- name: CreateSubscriptionScheduleEvent :one

INSERT INTO subscription_schedule (
    tenant_id,
    subscription_id,
    event_type,
    status,
    scheduled_at,
    order_id,
    payment_id,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, tenant_id, subscription_id, event_type, status, order_id, payment_id, error_message, retry_count, scheduled_at, processed_at, failed_at, metadata, created_at, updated_at
`

type CreateSubscriptionScheduleEventParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	SubscriptionID pgtype.UUID        `json:"subscription_id"`
	EventType      string             `json:"event_type"`
	Status         string             `json:"status"`
	ScheduledAt    pgtype.Timestamptz `json:"scheduled_at"`
	OrderID        pgtype.UUID        `json:"order_id"`
	PaymentID      pgtype.UUID        `json:"payment_id"`
	Metadata       []byte             `json:"metadata"`
}

// Subscription schedule queries
// Records a subscription schedule event (billing, pause, resume, cancel, etc.)
func (q *Queries) CreateSubscriptionScheduleEvent(ctx context.Context, arg CreateSubscriptionScheduleEventParams) (SubscriptionSchedule, error) {
	row := q.db.QueryRow(ctx, createSubscriptionScheduleEvent,
		arg.TenantID,
		arg.SubscriptionID,
		arg.EventType,
		arg.Status,
		arg.ScheduledAt,
		arg.OrderID,
		arg.PaymentID,
		arg.Metadata,
	)
	var i SubscriptionSchedule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Status,
		&i.OrderID,
		&i.PaymentID,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.FailedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebhookEvent = `-- name: CreateWebhookEvent :one
INSERT INTO webhook_events (
    tenant_id,
    provider,
    provider_event_id,
    event_type,
    status,
    payload
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (provider, provider_event_id) DO NOTHING
RETURNING id, tenant_id, provider, provider_event_id, event_type, status, payload, processed_at, error_message, retry_count, created_at, updated_at
`

type CreateWebhookEventParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	Provider        string      `json:"provider"`
	ProviderEventID string      `json:"provider_event_id"`
	EventType       string      `json:"event_type"`
	Status          string      `json:"status"`
	Payload         []byte      `json:"payload"`
}

// Record incoming webhook event for idempotency
func (q *Queries) CreateWebhookEvent(ctx context.Context, arg CreateWebhookEventParams) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, createWebhookEvent,
		arg.TenantID,
		arg.Provider,
		arg.ProviderEventID,
		arg.EventType,
		arg.Status,
		arg.Payload,
	)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Provider,
		&i.ProviderEventID,
		&i.EventType,
		&i.Status,
		&i.Payload,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBillingCustomerByProviderID = `-- name: GetBillingCustomerByProviderID :one
SELECT id, tenant_id, user_id, provider, provider_customer_id, metadata, created_at, updated_at FROM billing_customers
WHERE provider_customer_id = $1
  AND provider = $2
  AND tenant_id = $3
`

type GetBillingCustomerByProviderIDParams struct {
	ProviderCustomerID string      `json:"provider_customer_id"`
	Provider           string      `json:"provider"`
	TenantID           pgtype.UUID `json:"tenant_id"`
}

// Retrieves billing customer by Stripe customer ID
// Used for webhook processing
func (q *Queries) GetBillingCustomerByProviderID(ctx context.Context, arg GetBillingCustomerByProviderIDParams) (BillingCustomer, error) {
	row := q.db.QueryRow(ctx, getBillingCustomerByProviderID, arg.ProviderCustomerID, arg.Provider, arg.TenantID)
	var i BillingCustomer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBillingCustomerForUser = `-- name: GetBillingCustomerForUser :one

SELECT id, tenant_id, user_id, provider, provider_customer_id, metadata, created_at, updated_at FROM billing_customers
WHERE user_id = $1
  AND tenant_id = $2
  AND provider = $3
`

type GetBillingCustomerForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Provider string      `json:"provider"`
}

// Billing customer queries
// Retrieves billing customer record for user
// Used to get Stripe customer ID for subscription creation
func (q *Queries) GetBillingCustomerForUser(ctx context.Context, arg GetBillingCustomerForUserParams) (BillingCustomer, error) {
	row := q.db.QueryRow(ctx, getBillingCustomerForUser, arg.UserID, arg.TenantID, arg.Provider)
	var i BillingCustomer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefaultPaymentMethodForUser = `-- name: GetDefaultPaymentMethodForUser :one

SELECT pm.id, pm.tenant_id, pm.billing_customer_id, pm.provider, pm.provider_payment_method_id, pm.method_type, pm.display_brand, pm.display_last4, pm.display_exp_month, pm.display_exp_year, pm.is_default, pm.metadata, pm.created_at, pm.updated_at FROM payment_methods pm
JOIN billing_customers bc ON pm.billing_customer_id = bc.id
WHERE bc.user_id = $1
  AND bc.tenant_id = $2
  AND bc.provider = $3
  AND pm.is_default = true
`

type GetDefaultPaymentMethodForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Provider string      `json:"provider"`
}

// Payment method queries
// Retrieves user's default payment method
// Required for subscription creation
func (q *Queries) GetDefaultPaymentMethodForUser(ctx context.Context, arg GetDefaultPaymentMethodForUserParams) (PaymentMethod, error) {
	row := q.db.QueryRow(ctx, getDefaultPaymentMethodForUser, arg.UserID, arg.TenantID, arg.Provider)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentMethodID,
		&i.MethodType,
		&i.DisplayBrand,
		&i.DisplayLast4,
		&i.DisplayExpMonth,
		&i.DisplayExpYear,
		&i.IsDefault,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at FROM subscriptions
WHERE id = $1 AND tenant_id = $2
`

type GetSubscriptionByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Retrieves subscription by database ID with tenant scoping
func (q *Queries) GetSubscriptionByID(ctx context.Context, arg GetSubscriptionByIDParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, arg.ID, arg.TenantID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByProviderID = `-- name: GetSubscriptionByProviderID :one
SELECT id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at FROM subscriptions
WHERE provider_subscription_id = $1
  AND provider = $2
  AND tenant_id = $3
`

type GetSubscriptionByProviderIDParams struct {
	ProviderSubscriptionID pgtype.Text `json:"provider_subscription_id"`
	Provider               string      `json:"provider"`
	TenantID               pgtype.UUID `json:"tenant_id"`
}

// Retrieves subscription by Stripe subscription ID
// Used for webhook processing to find local subscription
func (q *Queries) GetSubscriptionByProviderID(ctx context.Context, arg GetSubscriptionByProviderIDParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByProviderID, arg.ProviderSubscriptionID, arg.Provider, arg.TenantID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionScheduleEventByInvoiceID = `-- name: GetSubscriptionScheduleEventByInvoiceID :one
SELECT id, tenant_id, subscription_id, event_type, status, order_id, payment_id, error_message, retry_count, scheduled_at, processed_at, failed_at, metadata, created_at, updated_at FROM subscription_schedule
WHERE tenant_id = $1
  AND subscription_id = $2
  AND event_type = 'billing'
  AND metadata->>'invoice_id' = $3
LIMIT 1
`

type GetSubscriptionScheduleEventByInvoiceIDParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	Metadata       []byte      `json:"metadata"`
}

// Checks if an invoice has already been processed (idempotency)
// Invoice ID is stored in metadata->>'invoice_id'
func (q *Queries) GetSubscriptionScheduleEventByInvoiceID(ctx context.Context, arg GetSubscriptionScheduleEventByInvoiceIDParams) (SubscriptionSchedule, error) {
	row := q.db.QueryRow(ctx, getSubscriptionScheduleEventByInvoiceID, arg.TenantID, arg.SubscriptionID, arg.Metadata)
	var i SubscriptionSchedule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Status,
		&i.OrderID,
		&i.PaymentID,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.FailedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionStats = `-- name: GetSubscriptionStats :one
SELECT
    COUNT(*) as total_subscriptions,
    COUNT(*) FILTER (WHERE status = 'active') as active_subscriptions,
    COUNT(*) FILTER (WHERE status = 'paused') as paused_subscriptions,
    COUNT(*) FILTER (WHERE status = 'past_due') as past_due_subscriptions,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_subscriptions,
    COALESCE(SUM(total_cents) FILTER (WHERE status = 'active'), 0) as monthly_recurring_revenue_cents
FROM subscriptions
WHERE tenant_id = $1
`

type GetSubscriptionStatsRow struct {
	TotalSubscriptions           int64       `json:"total_subscriptions"`
	ActiveSubscriptions          int64       `json:"active_subscriptions"`
	PausedSubscriptions          int64       `json:"paused_subscriptions"`
	PastDueSubscriptions         int64       `json:"past_due_subscriptions"`
	CancelledSubscriptions       int64       `json:"cancelled_subscriptions"`
	MonthlyRecurringRevenueCents interface{} `json:"monthly_recurring_revenue_cents"`
}

// Get subscription statistics for dashboard
func (q *Queries) GetSubscriptionStats(ctx context.Context, tenantID pgtype.UUID) (GetSubscriptionStatsRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionStats, tenantID)
	var i GetSubscriptionStatsRow
	err := row.Scan(
		&i.TotalSubscriptions,
		&i.ActiveSubscriptions,
		&i.PausedSubscriptions,
		&i.PastDueSubscriptions,
		&i.CancelledSubscriptions,
		&i.MonthlyRecurringRevenueCents,
	)
	return i, err
}

const getSubscriptionSummariesForUser = `-- name: GetSubscriptionSummariesForUser :many

SELECT
    s.id,
    s.status,
    s.billing_interval,
    s.total_cents,
    s.currency,
    s.next_billing_date,
    s.cancel_at_period_end,
    s.created_at,
    p.name as product_name,
    pi.url as product_image_url
FROM subscriptions s
JOIN subscription_items si ON si.subscription_id = s.id
JOIN product_skus ps ON si.product_sku_id = ps.id
JOIN products p ON ps.product_id = p.id
LEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = true
WHERE s.user_id = $1
  AND s.tenant_id = $2
ORDER BY s.created_at DESC
`

type GetSubscriptionSummariesForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetSubscriptionSummariesForUserRow struct {
	ID                pgtype.UUID        `json:"id"`
	Status            string             `json:"status"`
	BillingInterval   string             `json:"billing_interval"`
	TotalCents        int32              `json:"total_cents"`
	Currency          string             `json:"currency"`
	NextBillingDate   pgtype.Timestamptz `json:"next_billing_date"`
	CancelAtPeriodEnd bool               `json:"cancel_at_period_end"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	ProductName       string             `json:"product_name"`
	ProductImageUrl   pgtype.Text        `json:"product_image_url"`
}

// Subscription summary for customer account page
// Get subscription summaries with primary product info for customer display
func (q *Queries) GetSubscriptionSummariesForUser(ctx context.Context, arg GetSubscriptionSummariesForUserParams) ([]GetSubscriptionSummariesForUserRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionSummariesForUser, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionSummariesForUserRow{}
	for rows.Next() {
		var i GetSubscriptionSummariesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.BillingInterval,
			&i.TotalCents,
			&i.Currency,
			&i.NextBillingDate,
			&i.CancelAtPeriodEnd,
			&i.CreatedAt,
			&i.ProductName,
			&i.ProductImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionWithDetails = `-- name: GetSubscriptionWithDetails :one
SELECT
    s.id, s.tenant_id, s.user_id, s.subscription_plan_id, s.billing_interval, s.status, s.billing_customer_id, s.provider, s.provider_subscription_id, s.subtotal_cents, s.tax_cents, s.total_cents, s.currency, s.shipping_address_id, s.shipping_method_id, s.shipping_cents, s.payment_method_id, s.trial_ends_at, s.current_period_start, s.current_period_end, s.next_billing_date, s.cancel_at_period_end, s.cancelled_at, s.cancellation_reason, s.metadata, s.created_at, s.updated_at,
    u.email as user_email,
    u.first_name,
    u.last_name,
    a.full_name as shipping_full_name,
    a.company as shipping_company,
    a.address_line1 as shipping_address_line1,
    a.address_line2 as shipping_address_line2,
    a.city as shipping_city,
    a.state as shipping_state,
    a.postal_code as shipping_postal_code,
    a.country as shipping_country,
    a.phone as shipping_phone,
    pm.method_type as payment_method_type,
    pm.display_brand as payment_display_brand,
    pm.display_last4 as payment_display_last4,
    pm.display_exp_month as payment_display_exp_month,
    pm.display_exp_year as payment_display_exp_year,
    bc.provider_customer_id
FROM subscriptions s
JOIN users u ON s.user_id = u.id
JOIN addresses a ON s.shipping_address_id = a.id
LEFT JOIN payment_methods pm ON s.payment_method_id = pm.id
LEFT JOIN billing_customers bc ON s.billing_customer_id = bc.id
WHERE s.id = $1 AND s.tenant_id = $2
`

type GetSubscriptionWithDetailsParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

type GetSubscriptionWithDetailsRow struct {
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
	UserID                 pgtype.UUID        `json:"user_id"`
	SubscriptionPlanID     pgtype.UUID        `json:"subscription_plan_id"`
	BillingInterval        string             `json:"billing_interval"`
	Status                 string             `json:"status"`
	BillingCustomerID      pgtype.UUID        `json:"billing_customer_id"`
	Provider               string             `json:"provider"`
	ProviderSubscriptionID pgtype.Text        `json:"provider_subscription_id"`
	SubtotalCents          int32              `json:"subtotal_cents"`
	TaxCents               int32              `json:"tax_cents"`
	TotalCents             int32              `json:"total_cents"`
	Currency               string             `json:"currency"`
	ShippingAddressID      pgtype.UUID        `json:"shipping_address_id"`
	ShippingMethodID       pgtype.UUID        `json:"shipping_method_id"`
	ShippingCents          int32              `json:"shipping_cents"`
	PaymentMethodID        pgtype.UUID        `json:"payment_method_id"`
	TrialEndsAt            pgtype.Timestamptz `json:"trial_ends_at"`
	CurrentPeriodStart     pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd       pgtype.Timestamptz `json:"current_period_end"`
	NextBillingDate        pgtype.Timestamptz `json:"next_billing_date"`
	CancelAtPeriodEnd      bool               `json:"cancel_at_period_end"`
	CancelledAt            pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason     pgtype.Text        `json:"cancellation_reason"`
	Metadata               []byte             `json:"metadata"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	UserEmail              string             `json:"user_email"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
	ShippingFullName       pgtype.Text        `json:"shipping_full_name"`
	ShippingCompany        pgtype.Text        `json:"shipping_company"`
	ShippingAddressLine1   string             `json:"shipping_address_line1"`
	ShippingAddressLine2   pgtype.Text        `json:"shipping_address_line2"`
	ShippingCity           string             `json:"shipping_city"`
	ShippingState          string             `json:"shipping_state"`
	ShippingPostalCode     string             `json:"shipping_postal_code"`
	ShippingCountry        string             `json:"shipping_country"`
	ShippingPhone          pgtype.Text        `json:"shipping_phone"`
	PaymentMethodType      pgtype.Text        `json:"payment_method_type"`
	PaymentDisplayBrand    pgtype.Text        `json:"payment_display_brand"`
	PaymentDisplayLast4    pgtype.Text        `json:"payment_display_last4"`
	PaymentDisplayExpMonth pgtype.Int4        `json:"payment_display_exp_month"`
	PaymentDisplayExpYear  pgtype.Int4        `json:"payment_display_exp_year"`
	ProviderCustomerID     pgtype.Text        `json:"provider_customer_id"`
}

// Retrieves subscription with joined user, address, and payment method details
// Used for displaying subscription information to customers
func (q *Queries) GetSubscriptionWithDetails(ctx context.Context, arg GetSubscriptionWithDetailsParams) (GetSubscriptionWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionWithDetails, arg.ID, arg.TenantID)
	var i GetSubscriptionWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserEmail,
		&i.FirstName,
		&i.LastName,
		&i.ShippingFullName,
		&i.ShippingCompany,
		&i.ShippingAddressLine1,
		&i.ShippingAddressLine2,
		&i.ShippingCity,
		&i.ShippingState,
		&i.ShippingPostalCode,
		&i.ShippingCountry,
		&i.ShippingPhone,
		&i.PaymentMethodType,
		&i.PaymentDisplayBrand,
		&i.PaymentDisplayLast4,
		&i.PaymentDisplayExpMonth,
		&i.PaymentDisplayExpYear,
		&i.ProviderCustomerID,
	)
	return i, err
}

const getWebhookEventByProviderID = `-- name: GetWebhookEventByProviderID :one

SELECT id, tenant_id, provider, provider_event_id, event_type, status, payload, processed_at, error_message, retry_count, created_at, updated_at FROM webhook_events
WHERE provider_event_id = $1
  AND provider = $2
  AND tenant_id = $3
`

type GetWebhookEventByProviderIDParams struct {
	ProviderEventID string      `json:"provider_event_id"`
	Provider        string      `json:"provider"`
	TenantID        pgtype.UUID `json:"tenant_id"`
}

// Webhook event queries for subscription idempotency
// Check if webhook event was already processed
func (q *Queries) GetWebhookEventByProviderID(ctx context.Context, arg GetWebhookEventByProviderIDParams) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, getWebhookEventByProviderID, arg.ProviderEventID, arg.Provider, arg.TenantID)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Provider,
		&i.ProviderEventID,
		&i.EventType,
		&i.Status,
		&i.Payload,
		&i.ProcessedAt,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveSubscriptionsForUser = `-- name: ListActiveSubscriptionsForUser :many
SELECT id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at FROM subscriptions
WHERE user_id = $1
  AND tenant_id = $2
  AND status IN ('active', 'trial')
ORDER BY created_at DESC
`

type ListActiveSubscriptionsForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Lists only active/trial subscriptions for a customer
// Used for checking if user has active subscriptions
func (q *Queries) ListActiveSubscriptionsForUser(ctx context.Context, arg ListActiveSubscriptionsForUserParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listActiveSubscriptionsForUser, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.SubscriptionPlanID,
			&i.BillingInterval,
			&i.Status,
			&i.BillingCustomerID,
			&i.Provider,
			&i.ProviderSubscriptionID,
			&i.SubtotalCents,
			&i.TaxCents,
			&i.TotalCents,
			&i.Currency,
			&i.ShippingAddressID,
			&i.ShippingMethodID,
			&i.ShippingCents,
			&i.PaymentMethodID,
			&i.TrialEndsAt,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextBillingDate,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionItemsForSubscription = `-- name: ListSubscriptionItemsForSubscription :many
SELECT
    si.id, si.tenant_id, si.subscription_id, si.product_sku_id, si.quantity, si.unit_price_cents, si.metadata, si.created_at, si.updated_at,
    p.name as product_name,
    ps.sku,
    ps.weight_value,
    ps.weight_unit,
    ps.grind,
    pi.url as product_image_url
FROM subscription_items si
JOIN product_skus ps ON si.product_sku_id = ps.id
JOIN products p ON ps.product_id = p.id
LEFT JOIN product_images pi ON p.id = pi.product_id AND pi.is_primary = true
WHERE si.subscription_id = $1
  AND si.tenant_id = $2
ORDER BY si.created_at
`

type ListSubscriptionItemsForSubscriptionParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
}

type ListSubscriptionItemsForSubscriptionRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	SubscriptionID  pgtype.UUID        `json:"subscription_id"`
	ProductSkuID    pgtype.UUID        `json:"product_sku_id"`
	Quantity        int32              `json:"quantity"`
	UnitPriceCents  int32              `json:"unit_price_cents"`
	Metadata        []byte             `json:"metadata"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ProductName     string             `json:"product_name"`
	Sku             string             `json:"sku"`
	WeightValue     pgtype.Numeric     `json:"weight_value"`
	WeightUnit      string             `json:"weight_unit"`
	Grind           string             `json:"grind"`
	ProductImageUrl pgtype.Text        `json:"product_image_url"`
}

// Lists all items in a subscription with product details
// Includes product name, SKU, and image for display
func (q *Queries) ListSubscriptionItemsForSubscription(ctx context.Context, arg ListSubscriptionItemsForSubscriptionParams) ([]ListSubscriptionItemsForSubscriptionRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptionItemsForSubscription, arg.SubscriptionID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionItemsForSubscriptionRow{}
	for rows.Next() {
		var i ListSubscriptionItemsForSubscriptionRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.ProductSkuID,
			&i.Quantity,
			&i.UnitPriceCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
			&i.Sku,
			&i.WeightValue,
			&i.WeightUnit,
			&i.Grind,
			&i.ProductImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptions = `-- name: ListSubscriptions :many

SELECT
    s.id,
    s.tenant_id,
    s.status,
    s.billing_interval,
    s.total_cents,
    s.currency,
    s.next_billing_date,
    s.cancel_at_period_end,
    s.created_at,
    s.updated_at,
    u.email as customer_email,
    CONCAT(u.first_name, ' ', u.last_name) as customer_name
FROM subscriptions s
LEFT JOIN users u ON u.id = s.user_id
WHERE s.tenant_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type ListSubscriptionsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListSubscriptionsRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	Status            string             `json:"status"`
	BillingInterval   string             `json:"billing_interval"`
	TotalCents        int32              `json:"total_cents"`
	Currency          string             `json:"currency"`
	NextBillingDate   pgtype.Timestamptz `json:"next_billing_date"`
	CancelAtPeriodEnd bool               `json:"cancel_at_period_end"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	CustomerEmail     pgtype.Text        `json:"customer_email"`
	CustomerName      interface{}        `json:"customer_name"`
}

// Admin queries
// List all subscriptions for admin with pagination
func (q *Queries) ListSubscriptions(ctx context.Context, arg ListSubscriptionsParams) ([]ListSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, listSubscriptions, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubscriptionsRow{}
	for rows.Next() {
		var i ListSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Status,
			&i.BillingInterval,
			&i.TotalCents,
			&i.Currency,
			&i.NextBillingDate,
			&i.CancelAtPeriodEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerEmail,
			&i.CustomerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByStatus = `-- name: ListSubscriptionsByStatus :many
SELECT id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at FROM subscriptions
WHERE tenant_id = $1
  AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSubscriptionsByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// Lists subscriptions filtered by status with pagination
// Used for admin filtering
func (q *Queries) ListSubscriptionsByStatus(ctx context.Context, arg ListSubscriptionsByStatusParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.SubscriptionPlanID,
			&i.BillingInterval,
			&i.Status,
			&i.BillingCustomerID,
			&i.Provider,
			&i.ProviderSubscriptionID,
			&i.SubtotalCents,
			&i.TaxCents,
			&i.TotalCents,
			&i.Currency,
			&i.ShippingAddressID,
			&i.ShippingMethodID,
			&i.ShippingCents,
			&i.PaymentMethodID,
			&i.TrialEndsAt,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextBillingDate,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsForUser = `-- name: ListSubscriptionsForUser :many
SELECT id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at FROM subscriptions
WHERE user_id = $1
  AND tenant_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSubscriptionsForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// Lists all subscriptions for a customer with pagination
// Returns newest first
func (q *Queries) ListSubscriptionsForUser(ctx context.Context, arg ListSubscriptionsForUserParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsForUser,
		arg.UserID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.SubscriptionPlanID,
			&i.BillingInterval,
			&i.Status,
			&i.BillingCustomerID,
			&i.Provider,
			&i.ProviderSubscriptionID,
			&i.SubtotalCents,
			&i.TaxCents,
			&i.TotalCents,
			&i.Currency,
			&i.ShippingAddressID,
			&i.ShippingMethodID,
			&i.ShippingCents,
			&i.PaymentMethodID,
			&i.TrialEndsAt,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.NextBillingDate,
			&i.CancelAtPeriodEnd,
			&i.CancelledAt,
			&i.CancellationReason,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingScheduleEvents = `-- name: ListUpcomingScheduleEvents :many
SELECT
    ss.id, ss.tenant_id, ss.subscription_id, ss.event_type, ss.status, ss.order_id, ss.payment_id, ss.error_message, ss.retry_count, ss.scheduled_at, ss.processed_at, ss.failed_at, ss.metadata, ss.created_at, ss.updated_at,
    s.user_id,
    s.provider_subscription_id
FROM subscription_schedule ss
JOIN subscriptions s ON ss.subscription_id = s.id
WHERE ss.tenant_id = $1
  AND ss.status = 'scheduled'
  AND ss.scheduled_at <= $2
ORDER BY ss.scheduled_at ASC
LIMIT $3
`

type ListUpcomingScheduleEventsParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	ScheduledAt pgtype.Timestamptz `json:"scheduled_at"`
	Limit       int32              `json:"limit"`
}

type ListUpcomingScheduleEventsRow struct {
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
	SubscriptionID         pgtype.UUID        `json:"subscription_id"`
	EventType              string             `json:"event_type"`
	Status                 string             `json:"status"`
	OrderID                pgtype.UUID        `json:"order_id"`
	PaymentID              pgtype.UUID        `json:"payment_id"`
	ErrorMessage           pgtype.Text        `json:"error_message"`
	RetryCount             int32              `json:"retry_count"`
	ScheduledAt            pgtype.Timestamptz `json:"scheduled_at"`
	ProcessedAt            pgtype.Timestamptz `json:"processed_at"`
	FailedAt               pgtype.Timestamptz `json:"failed_at"`
	Metadata               []byte             `json:"metadata"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	UserID                 pgtype.UUID        `json:"user_id"`
	ProviderSubscriptionID pgtype.Text        `json:"provider_subscription_id"`
}

// Lists upcoming scheduled events for processing
// Used by background job to process subscription renewals
func (q *Queries) ListUpcomingScheduleEvents(ctx context.Context, arg ListUpcomingScheduleEventsParams) ([]ListUpcomingScheduleEventsRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingScheduleEvents, arg.TenantID, arg.ScheduledAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingScheduleEventsRow{}
	for rows.Next() {
		var i ListUpcomingScheduleEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SubscriptionID,
			&i.EventType,
			&i.Status,
			&i.OrderID,
			&i.PaymentID,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.ProcessedAt,
			&i.FailedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.ProviderSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionCancellation = `-- name: UpdateSubscriptionCancellation :one
UPDATE subscriptions
SET
    cancel_at_period_end = $3,
    cancelled_at = CASE WHEN $3 = false THEN NOW() ELSE cancelled_at END,
    cancellation_reason = COALESCE($4, cancellation_reason),
    status = CASE WHEN $3 = false THEN 'cancelled' ELSE status END,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at
`

type UpdateSubscriptionCancellationParams struct {
	ID                 pgtype.UUID `json:"id"`
	TenantID           pgtype.UUID `json:"tenant_id"`
	CancelAtPeriodEnd  bool        `json:"cancel_at_period_end"`
	CancellationReason pgtype.Text `json:"cancellation_reason"`
}

// Marks subscription as cancelled or scheduled for cancellation
func (q *Queries) UpdateSubscriptionCancellation(ctx context.Context, arg UpdateSubscriptionCancellationParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionCancellation,
		arg.ID,
		arg.TenantID,
		arg.CancelAtPeriodEnd,
		arg.CancellationReason,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionPauseResume = `-- name: UpdateSubscriptionPauseResume :one
UPDATE subscriptions
SET
    status = $3,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at
`

type UpdateSubscriptionPauseResumeParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

// Updates subscription status for pause/resume operations
func (q *Queries) UpdateSubscriptionPauseResume(ctx context.Context, arg UpdateSubscriptionPauseResumeParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionPauseResume, arg.ID, arg.TenantID, arg.Status)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionProviderID = `-- name: UpdateSubscriptionProviderID :one
UPDATE subscriptions
SET
    provider_subscription_id = $3,
    status = $4,
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at
`

type UpdateSubscriptionProviderIDParams struct {
	ID                     pgtype.UUID `json:"id"`
	TenantID               pgtype.UUID `json:"tenant_id"`
	ProviderSubscriptionID pgtype.Text `json:"provider_subscription_id"`
	Status                 string      `json:"status"`
}

// Updates subscription with Stripe subscription ID after creation
// Called after Stripe subscription is created
func (q *Queries) UpdateSubscriptionProviderID(ctx context.Context, arg UpdateSubscriptionProviderIDParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionProviderID,
		arg.ID,
		arg.TenantID,
		arg.ProviderSubscriptionID,
		arg.Status,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionScheduleEvent = `-- name: UpdateSubscriptionScheduleEvent :one
UPDATE subscription_schedule
SET
    status = $3,
    processed_at = COALESCE($4, processed_at),
    failed_at = COALESCE($5, failed_at),
    error_message = COALESCE($6, error_message),
    retry_count = COALESCE($7, retry_count),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, subscription_id, event_type, status, order_id, payment_id, error_message, retry_count, scheduled_at, processed_at, failed_at, metadata, created_at, updated_at
`

type UpdateSubscriptionScheduleEventParams struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	Status       string             `json:"status"`
	ProcessedAt  pgtype.Timestamptz `json:"processed_at"`
	FailedAt     pgtype.Timestamptz `json:"failed_at"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	RetryCount   pgtype.Int4        `json:"retry_count"`
}

// Updates subscription schedule event status after processing
func (q *Queries) UpdateSubscriptionScheduleEvent(ctx context.Context, arg UpdateSubscriptionScheduleEventParams) (SubscriptionSchedule, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionScheduleEvent,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ProcessedAt,
		arg.FailedAt,
		arg.ErrorMessage,
		arg.RetryCount,
	)
	var i SubscriptionSchedule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SubscriptionID,
		&i.EventType,
		&i.Status,
		&i.OrderID,
		&i.PaymentID,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.FailedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions
SET
    status = $3,
    current_period_start = COALESCE($4, current_period_start),
    current_period_end = COALESCE($5, current_period_end),
    next_billing_date = COALESCE($6, next_billing_date),
    cancel_at_period_end = COALESCE($7, cancel_at_period_end),
    cancelled_at = COALESCE($8, cancelled_at),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, user_id, subscription_plan_id, billing_interval, status, billing_customer_id, provider, provider_subscription_id, subtotal_cents, tax_cents, total_cents, currency, shipping_address_id, shipping_method_id, shipping_cents, payment_method_id, trial_ends_at, current_period_start, current_period_end, next_billing_date, cancel_at_period_end, cancelled_at, cancellation_reason, metadata, created_at, updated_at
`

type UpdateSubscriptionStatusParams struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	Status             string             `json:"status"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
	NextBillingDate    pgtype.Timestamptz `json:"next_billing_date"`
	CancelAtPeriodEnd  pgtype.Bool        `json:"cancel_at_period_end"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
}

// Updates subscription status and related timestamps
// Used when syncing from Stripe webhooks
func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptionStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.NextBillingDate,
		arg.CancelAtPeriodEnd,
		arg.CancelledAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.SubscriptionPlanID,
		&i.BillingInterval,
		&i.Status,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderSubscriptionID,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.ShippingAddressID,
		&i.ShippingMethodID,
		&i.ShippingCents,
		&i.PaymentMethodID,
		&i.TrialEndsAt,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.NextBillingDate,
		&i.CancelAtPeriodEnd,
		&i.CancelledAt,
		&i.CancellationReason,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWebhookEventStatus = `-- name: UpdateWebhookEventStatus :exec
UPDATE webhook_events
SET
    status = $3,
    processed_at = CASE WHEN $3 = 'processed' THEN NOW() ELSE processed_at END,
    error_message = $4,
    retry_count = COALESCE($5, retry_count),
    updated_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type UpdateWebhookEventStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
	RetryCount   pgtype.Int4 `json:"retry_count"`
}

// Update webhook event status after processing
func (q *Queries) UpdateWebhookEventStatus(ctx context.Context, arg UpdateWebhookEventStatusParams) error {
	_, err := q.db.Exec(ctx, updateWebhookEventStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ErrorMessage,
		arg.RetryCount,
	)
	return err
}
