// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: billing.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPaymentMethodsForUser = `-- name: CountPaymentMethodsForUser :one
SELECT
    COUNT(*) as payment_method_count,
    COALESCE(BOOL_OR(pm.is_default), false) as has_default_payment
FROM payment_methods pm
INNER JOIN billing_customers bc ON bc.id = pm.billing_customer_id
WHERE bc.tenant_id = $1
  AND bc.user_id = $2
`

type CountPaymentMethodsForUserParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type CountPaymentMethodsForUserRow struct {
	PaymentMethodCount int64       `json:"payment_method_count"`
	HasDefaultPayment  interface{} `json:"has_default_payment"`
}

// Count payment methods for a user (for account dashboard)
func (q *Queries) CountPaymentMethodsForUser(ctx context.Context, arg CountPaymentMethodsForUserParams) (CountPaymentMethodsForUserRow, error) {
	row := q.db.QueryRow(ctx, countPaymentMethodsForUser, arg.TenantID, arg.UserID)
	var i CountPaymentMethodsForUserRow
	err := row.Scan(&i.PaymentMethodCount, &i.HasDefaultPayment)
	return i, err
}

const createBillingCustomer = `-- name: CreateBillingCustomer :one
INSERT INTO billing_customers (
    tenant_id,
    user_id,
    provider,
    provider_customer_id,
    metadata
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, user_id, provider, provider_customer_id, metadata, created_at, updated_at
`

type CreateBillingCustomerParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	UserID             pgtype.UUID `json:"user_id"`
	Provider           string      `json:"provider"`
	ProviderCustomerID string      `json:"provider_customer_id"`
	Metadata           []byte      `json:"metadata"`
}

// Create a new billing customer
func (q *Queries) CreateBillingCustomer(ctx context.Context, arg CreateBillingCustomerParams) (BillingCustomer, error) {
	row := q.db.QueryRow(ctx, createBillingCustomer,
		arg.TenantID,
		arg.UserID,
		arg.Provider,
		arg.ProviderCustomerID,
		arg.Metadata,
	)
	var i BillingCustomer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    tenant_id,
    billing_customer_id,
    provider,
    provider_payment_id,
    amount_cents,
    currency,
    status,
    payment_method_id,
    metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, billing_customer_id, provider, provider_payment_id, amount_cents, currency, status, payment_method_id, failure_code, failure_message, refunded_amount_cents, metadata, succeeded_at, failed_at, refunded_at, created_at, updated_at
`

type CreatePaymentParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	BillingCustomerID pgtype.UUID `json:"billing_customer_id"`
	Provider          string      `json:"provider"`
	ProviderPaymentID string      `json:"provider_payment_id"`
	AmountCents       int32       `json:"amount_cents"`
	Currency          string      `json:"currency"`
	Status            string      `json:"status"`
	PaymentMethodID   pgtype.UUID `json:"payment_method_id"`
	Metadata          []byte      `json:"metadata"`
}

// Create a new payment record
func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.TenantID,
		arg.BillingCustomerID,
		arg.Provider,
		arg.ProviderPaymentID,
		arg.AmountCents,
		arg.Currency,
		arg.Status,
		arg.PaymentMethodID,
		arg.Metadata,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.FailureCode,
		&i.FailureMessage,
		&i.RefundedAmountCents,
		&i.Metadata,
		&i.SucceededAt,
		&i.FailedAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO payment_methods (
    tenant_id,
    billing_customer_id,
    provider,
    provider_payment_method_id,
    method_type,
    display_brand,
    display_last4,
    display_exp_month,
    display_exp_year,
    is_default,
    metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, tenant_id, billing_customer_id, provider, provider_payment_method_id, method_type, display_brand, display_last4, display_exp_month, display_exp_year, is_default, metadata, created_at, updated_at
`

type CreatePaymentMethodParams struct {
	TenantID                pgtype.UUID `json:"tenant_id"`
	BillingCustomerID       pgtype.UUID `json:"billing_customer_id"`
	Provider                string      `json:"provider"`
	ProviderPaymentMethodID string      `json:"provider_payment_method_id"`
	MethodType              string      `json:"method_type"`
	DisplayBrand            pgtype.Text `json:"display_brand"`
	DisplayLast4            pgtype.Text `json:"display_last4"`
	DisplayExpMonth         pgtype.Int4 `json:"display_exp_month"`
	DisplayExpYear          pgtype.Int4 `json:"display_exp_year"`
	IsDefault               bool        `json:"is_default"`
	Metadata                []byte      `json:"metadata"`
}

// Create a new payment method
func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) (PaymentMethod, error) {
	row := q.db.QueryRow(ctx, createPaymentMethod,
		arg.TenantID,
		arg.BillingCustomerID,
		arg.Provider,
		arg.ProviderPaymentMethodID,
		arg.MethodType,
		arg.DisplayBrand,
		arg.DisplayLast4,
		arg.DisplayExpMonth,
		arg.DisplayExpYear,
		arg.IsDefault,
		arg.Metadata,
	)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentMethodID,
		&i.MethodType,
		&i.DisplayBrand,
		&i.DisplayLast4,
		&i.DisplayExpMonth,
		&i.DisplayExpYear,
		&i.IsDefault,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePaymentMethod = `-- name: DeletePaymentMethod :exec
DELETE FROM payment_methods
WHERE tenant_id = $1
  AND id = $2
`

type DeletePaymentMethodParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Delete a payment method
func (q *Queries) DeletePaymentMethod(ctx context.Context, arg DeletePaymentMethodParams) error {
	_, err := q.db.Exec(ctx, deletePaymentMethod, arg.TenantID, arg.ID)
	return err
}

const getBillingCustomerByUserID = `-- name: GetBillingCustomerByUserID :one
SELECT id, tenant_id, user_id, provider, provider_customer_id, metadata, created_at, updated_at
FROM billing_customers
WHERE tenant_id = $1
  AND user_id = $2
  AND provider = $3
LIMIT 1
`

type GetBillingCustomerByUserIDParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
	Provider string      `json:"provider"`
}

// Get billing customer for a user
func (q *Queries) GetBillingCustomerByUserID(ctx context.Context, arg GetBillingCustomerByUserIDParams) (BillingCustomer, error) {
	row := q.db.QueryRow(ctx, getBillingCustomerByUserID, arg.TenantID, arg.UserID, arg.Provider)
	var i BillingCustomer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefaultPaymentMethod = `-- name: GetDefaultPaymentMethod :one
SELECT
    pm.id,
    pm.tenant_id,
    pm.billing_customer_id,
    pm.provider,
    pm.provider_payment_method_id,
    pm.method_type,
    pm.display_brand,
    pm.display_last4,
    pm.display_exp_month,
    pm.display_exp_year,
    pm.is_default,
    pm.created_at,
    pm.updated_at
FROM payment_methods pm
INNER JOIN billing_customers bc ON bc.id = pm.billing_customer_id
WHERE bc.tenant_id = $1
  AND bc.user_id = $2
  AND pm.is_default = TRUE
LIMIT 1
`

type GetDefaultPaymentMethodParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type GetDefaultPaymentMethodRow struct {
	ID                      pgtype.UUID        `json:"id"`
	TenantID                pgtype.UUID        `json:"tenant_id"`
	BillingCustomerID       pgtype.UUID        `json:"billing_customer_id"`
	Provider                string             `json:"provider"`
	ProviderPaymentMethodID string             `json:"provider_payment_method_id"`
	MethodType              string             `json:"method_type"`
	DisplayBrand            pgtype.Text        `json:"display_brand"`
	DisplayLast4            pgtype.Text        `json:"display_last4"`
	DisplayExpMonth         pgtype.Int4        `json:"display_exp_month"`
	DisplayExpYear          pgtype.Int4        `json:"display_exp_year"`
	IsDefault               bool               `json:"is_default"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
}

// Get the default payment method for a user
func (q *Queries) GetDefaultPaymentMethod(ctx context.Context, arg GetDefaultPaymentMethodParams) (GetDefaultPaymentMethodRow, error) {
	row := q.db.QueryRow(ctx, getDefaultPaymentMethod, arg.TenantID, arg.UserID)
	var i GetDefaultPaymentMethodRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentMethodID,
		&i.MethodType,
		&i.DisplayBrand,
		&i.DisplayLast4,
		&i.DisplayExpMonth,
		&i.DisplayExpYear,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByProviderID = `-- name: GetPaymentByProviderID :one
SELECT id, tenant_id, billing_customer_id, provider, provider_payment_id, amount_cents, currency, status, payment_method_id, failure_code, failure_message, refunded_amount_cents, metadata, succeeded_at, failed_at, refunded_at, created_at, updated_at
FROM payments
WHERE tenant_id = $1
  AND provider = $2
  AND provider_payment_id = $3
LIMIT 1
`

type GetPaymentByProviderIDParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	Provider          string      `json:"provider"`
	ProviderPaymentID string      `json:"provider_payment_id"`
}

// Get a payment by provider payment ID
func (q *Queries) GetPaymentByProviderID(ctx context.Context, arg GetPaymentByProviderIDParams) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByProviderID, arg.TenantID, arg.Provider, arg.ProviderPaymentID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.FailureCode,
		&i.FailureMessage,
		&i.RefundedAmountCents,
		&i.Metadata,
		&i.SucceededAt,
		&i.FailedAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentMethodByID = `-- name: GetPaymentMethodByID :one
SELECT
    pm.id,
    pm.tenant_id,
    pm.billing_customer_id,
    pm.provider,
    pm.provider_payment_method_id,
    pm.method_type,
    pm.display_brand,
    pm.display_last4,
    pm.display_exp_month,
    pm.display_exp_year,
    pm.is_default,
    pm.created_at,
    pm.updated_at
FROM payment_methods pm
INNER JOIN billing_customers bc ON bc.id = pm.billing_customer_id
WHERE pm.id = $1
  AND bc.tenant_id = $2
  AND bc.user_id = $3
LIMIT 1
`

type GetPaymentMethodByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type GetPaymentMethodByIDRow struct {
	ID                      pgtype.UUID        `json:"id"`
	TenantID                pgtype.UUID        `json:"tenant_id"`
	BillingCustomerID       pgtype.UUID        `json:"billing_customer_id"`
	Provider                string             `json:"provider"`
	ProviderPaymentMethodID string             `json:"provider_payment_method_id"`
	MethodType              string             `json:"method_type"`
	DisplayBrand            pgtype.Text        `json:"display_brand"`
	DisplayLast4            pgtype.Text        `json:"display_last4"`
	DisplayExpMonth         pgtype.Int4        `json:"display_exp_month"`
	DisplayExpYear          pgtype.Int4        `json:"display_exp_year"`
	IsDefault               bool               `json:"is_default"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
}

// Get a single payment method by ID (validates user ownership)
func (q *Queries) GetPaymentMethodByID(ctx context.Context, arg GetPaymentMethodByIDParams) (GetPaymentMethodByIDRow, error) {
	row := q.db.QueryRow(ctx, getPaymentMethodByID, arg.ID, arg.TenantID, arg.UserID)
	var i GetPaymentMethodByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentMethodID,
		&i.MethodType,
		&i.DisplayBrand,
		&i.DisplayLast4,
		&i.DisplayExpMonth,
		&i.DisplayExpYear,
		&i.IsDefault,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPaymentMethodsForUser = `-- name: ListPaymentMethodsForUser :many
SELECT
    pm.id,
    pm.tenant_id,
    pm.billing_customer_id,
    pm.provider,
    pm.provider_payment_method_id,
    pm.method_type,
    pm.display_brand,
    pm.display_last4,
    pm.display_exp_month,
    pm.display_exp_year,
    pm.is_default,
    pm.created_at,
    pm.updated_at
FROM payment_methods pm
INNER JOIN billing_customers bc ON bc.id = pm.billing_customer_id
WHERE bc.tenant_id = $1
  AND bc.user_id = $2
ORDER BY pm.is_default DESC, pm.created_at DESC
`

type ListPaymentMethodsForUserParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type ListPaymentMethodsForUserRow struct {
	ID                      pgtype.UUID        `json:"id"`
	TenantID                pgtype.UUID        `json:"tenant_id"`
	BillingCustomerID       pgtype.UUID        `json:"billing_customer_id"`
	Provider                string             `json:"provider"`
	ProviderPaymentMethodID string             `json:"provider_payment_method_id"`
	MethodType              string             `json:"method_type"`
	DisplayBrand            pgtype.Text        `json:"display_brand"`
	DisplayLast4            pgtype.Text        `json:"display_last4"`
	DisplayExpMonth         pgtype.Int4        `json:"display_exp_month"`
	DisplayExpYear          pgtype.Int4        `json:"display_exp_year"`
	IsDefault               bool               `json:"is_default"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
}

// Get all payment methods for a user
func (q *Queries) ListPaymentMethodsForUser(ctx context.Context, arg ListPaymentMethodsForUserParams) ([]ListPaymentMethodsForUserRow, error) {
	rows, err := q.db.Query(ctx, listPaymentMethodsForUser, arg.TenantID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentMethodsForUserRow{}
	for rows.Next() {
		var i ListPaymentMethodsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.BillingCustomerID,
			&i.Provider,
			&i.ProviderPaymentMethodID,
			&i.MethodType,
			&i.DisplayBrand,
			&i.DisplayLast4,
			&i.DisplayExpMonth,
			&i.DisplayExpYear,
			&i.IsDefault,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultPaymentMethod = `-- name: SetDefaultPaymentMethod :exec
UPDATE payment_methods
SET is_default = (id = $2)
WHERE billing_customer_id = $1
`

type SetDefaultPaymentMethodParams struct {
	BillingCustomerID pgtype.UUID `json:"billing_customer_id"`
	ID                pgtype.UUID `json:"id"`
}

// Set a payment method as the default for a billing customer
func (q *Queries) SetDefaultPaymentMethod(ctx context.Context, arg SetDefaultPaymentMethodParams) error {
	_, err := q.db.Exec(ctx, setDefaultPaymentMethod, arg.BillingCustomerID, arg.ID)
	return err
}

const updateBillingCustomer = `-- name: UpdateBillingCustomer :one
UPDATE billing_customers
SET
    provider_customer_id = $4,
    metadata = $5,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
  AND provider = $3
RETURNING id, tenant_id, user_id, provider, provider_customer_id, metadata, created_at, updated_at
`

type UpdateBillingCustomerParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	ID                 pgtype.UUID `json:"id"`
	Provider           string      `json:"provider"`
	ProviderCustomerID string      `json:"provider_customer_id"`
	Metadata           []byte      `json:"metadata"`
}

// Update a billing customer
func (q *Queries) UpdateBillingCustomer(ctx context.Context, arg UpdateBillingCustomerParams) (BillingCustomer, error) {
	row := q.db.QueryRow(ctx, updateBillingCustomer,
		arg.TenantID,
		arg.ID,
		arg.Provider,
		arg.ProviderCustomerID,
		arg.Metadata,
	)
	var i BillingCustomer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET
    status = $3,
    succeeded_at = CASE WHEN $3 = 'succeeded' THEN NOW() ELSE succeeded_at END,
    failed_at = CASE WHEN $3 = 'failed' THEN NOW() ELSE failed_at END,
    failure_code = $4,
    failure_message = $5,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
RETURNING id, tenant_id, billing_customer_id, provider, provider_payment_id, amount_cents, currency, status, payment_method_id, failure_code, failure_message, refunded_amount_cents, metadata, succeeded_at, failed_at, refunded_at, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	ID             pgtype.UUID `json:"id"`
	Status         string      `json:"status"`
	FailureCode    pgtype.Text `json:"failure_code"`
	FailureMessage pgtype.Text `json:"failure_message"`
}

// Update payment status
func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus,
		arg.TenantID,
		arg.ID,
		arg.Status,
		arg.FailureCode,
		arg.FailureMessage,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.FailureCode,
		&i.FailureMessage,
		&i.RefundedAmountCents,
		&i.Metadata,
		&i.SucceededAt,
		&i.FailedAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
