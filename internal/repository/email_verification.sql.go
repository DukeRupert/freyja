// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: email_verification.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRecentVerificationRequestsByIP = `-- name: CountRecentVerificationRequestsByIP :one
SELECT COUNT(*)
FROM email_verification_tokens
WHERE ip_address = $1
  AND created_at > $2
`

type CountRecentVerificationRequestsByIPParams struct {
	IpAddress pgtype.Text        `json:"ip_address"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Count recent email verification requests from a specific IP address (rate limiting)
func (q *Queries) CountRecentVerificationRequestsByIP(ctx context.Context, arg CountRecentVerificationRequestsByIPParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentVerificationRequestsByIP, arg.IpAddress, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentVerificationRequestsByUser = `-- name: CountRecentVerificationRequestsByUser :one
SELECT COUNT(*)
FROM email_verification_tokens
WHERE user_id = $1
  AND created_at > $2
`

type CountRecentVerificationRequestsByUserParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Count recent email verification requests for a specific user (rate limiting)
func (q *Queries) CountRecentVerificationRequestsByUser(ctx context.Context, arg CountRecentVerificationRequestsByUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentVerificationRequestsByUser, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmailVerificationToken = `-- name: CreateEmailVerificationToken :one
INSERT INTO email_verification_tokens (
    tenant_id,
    user_id,
    token_hash,
    expires_at,
    ip_address,
    user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, user_id, token_hash, used, used_at, expires_at, ip_address, user_agent, created_at
`

type CreateEmailVerificationTokenParams struct {
	TenantID  pgtype.UUID        `json:"tenant_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	IpAddress pgtype.Text        `json:"ip_address"`
	UserAgent pgtype.Text        `json:"user_agent"`
}

// Create a new email verification token
func (q *Queries) CreateEmailVerificationToken(ctx context.Context, arg CreateEmailVerificationTokenParams) (EmailVerificationToken, error) {
	row := q.db.QueryRow(ctx, createEmailVerificationToken,
		arg.TenantID,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i EmailVerificationToken
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.Used,
		&i.UsedAt,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredEmailVerificationTokens = `-- name: DeleteExpiredEmailVerificationTokens :exec
DELETE FROM email_verification_tokens
WHERE expires_at <= NOW()
`

// Delete expired email verification tokens (cleanup job)
func (q *Queries) DeleteExpiredEmailVerificationTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredEmailVerificationTokens)
	return err
}

const getEmailVerificationToken = `-- name: GetEmailVerificationToken :one
SELECT
    evt.id,
    evt.tenant_id,
    evt.user_id,
    evt.token_hash,
    evt.used,
    evt.used_at,
    evt.expires_at,
    evt.created_at,
    u.email as user_email,
    u.first_name as user_first_name,
    u.last_name as user_last_name,
    u.status as user_status,
    u.email_verified as user_email_verified
FROM email_verification_tokens evt
INNER JOIN users u ON evt.user_id = u.id
WHERE evt.tenant_id = $1
  AND evt.token_hash = $2
  AND evt.used = FALSE
  AND evt.expires_at > NOW()
LIMIT 1
`

type GetEmailVerificationTokenParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	TokenHash string      `json:"token_hash"`
}

type GetEmailVerificationTokenRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	TokenHash         string             `json:"token_hash"`
	Used              bool               `json:"used"`
	UsedAt            pgtype.Timestamptz `json:"used_at"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UserEmail         string             `json:"user_email"`
	UserFirstName     pgtype.Text        `json:"user_first_name"`
	UserLastName      pgtype.Text        `json:"user_last_name"`
	UserStatus        string             `json:"user_status"`
	UserEmailVerified bool               `json:"user_email_verified"`
}

// Get a valid (unused, non-expired) email verification token with user details
func (q *Queries) GetEmailVerificationToken(ctx context.Context, arg GetEmailVerificationTokenParams) (GetEmailVerificationTokenRow, error) {
	row := q.db.QueryRow(ctx, getEmailVerificationToken, arg.TenantID, arg.TokenHash)
	var i GetEmailVerificationTokenRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.TokenHash,
		&i.Used,
		&i.UsedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.UserStatus,
		&i.UserEmailVerified,
	)
	return i, err
}

const getPendingVerificationByUser = `-- name: GetPendingVerificationByUser :one
SELECT EXISTS(
    SELECT 1
    FROM email_verification_tokens
    WHERE user_id = $1
      AND used = FALSE
      AND expires_at > NOW()
) as has_pending_token
`

// Check if user has any pending (unused, non-expired) verification token
func (q *Queries) GetPendingVerificationByUser(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, getPendingVerificationByUser, userID)
	var has_pending_token bool
	err := row.Scan(&has_pending_token)
	return has_pending_token, err
}

const invalidateUserEmailVerificationTokens = `-- name: InvalidateUserEmailVerificationTokens :exec
UPDATE email_verification_tokens
SET
    used = TRUE,
    used_at = NOW()
WHERE tenant_id = $1
  AND user_id = $2
  AND used = FALSE
`

type InvalidateUserEmailVerificationTokensParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

// Mark all unused email verification tokens for a user as used
// (Called after successful email verification to invalidate other tokens)
func (q *Queries) InvalidateUserEmailVerificationTokens(ctx context.Context, arg InvalidateUserEmailVerificationTokensParams) error {
	_, err := q.db.Exec(ctx, invalidateUserEmailVerificationTokens, arg.TenantID, arg.UserID)
	return err
}

const markEmailVerificationTokenUsed = `-- name: MarkEmailVerificationTokenUsed :exec
UPDATE email_verification_tokens
SET
    used = TRUE,
    used_at = NOW()
WHERE tenant_id = $1
  AND token_hash = $2
  AND used = FALSE
`

type MarkEmailVerificationTokenUsedParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	TokenHash string      `json:"token_hash"`
}

// Mark an email verification token as used
func (q *Queries) MarkEmailVerificationTokenUsed(ctx context.Context, arg MarkEmailVerificationTokenUsedParams) error {
	_, err := q.db.Exec(ctx, markEmailVerificationTokenUsed, arg.TenantID, arg.TokenHash)
	return err
}
