// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateProduct = `-- name: ActivateProduct :one
UPDATE products
SET
  active = true,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, active, created_at, updated_at
`

func (q *Queries) ActivateProduct(ctx context.Context, id int32) (Products, error) {
	row := q.db.QueryRow(ctx, activateProduct, id)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO products (
  name, description, active
) VALUES (
  $1, $2, $3
)
RETURNING id, name, description, active, created_at, updated_at
`

type CreateProductParams struct {
	Name        string      `db:"name" json:"name"`
	Description pgtype.Text `db:"description" json:"description"`
	Active      bool        `db:"active" json:"active"`
}

// Product management queries (admin operations)
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Products, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.Name, arg.Description, arg.Active)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateProduct = `-- name: DeactivateProduct :one
UPDATE products
SET
  active = false,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, active, created_at, updated_at
`

func (q *Queries) DeactivateProduct(ctx context.Context, id int32) (Products, error) {
	row := q.db.QueryRow(ctx, deactivateProduct, id)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_active = true AND pss.total_stock <= $1
ORDER BY pss.total_stock ASC
`

func (q *Queries) GetLowStockProducts(ctx context.Context, totalStock interface{}) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts, totalStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one

SELECT p.id, p.name, p.description, p.active, p.created_at, p.updated_at
FROM products p
WHERE p.id = $1
`

// internal/database/queries/products.sql
// Updated for product variants system
func (q *Queries) GetProduct(ctx context.Context, id int32) (Products, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByName = `-- name: GetProductByName :one
SELECT p.id, p.name, p.description, p.active, p.created_at, p.updated_at
FROM products p
WHERE p.name = $1
`

func (q *Queries) GetProductByName(ctx context.Context, name string) (Products, error) {
	row := q.db.QueryRow(ctx, getProductByName, name)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductPerformanceStats = `-- name: GetProductPerformanceStats :many

SELECT 
    p.id,
    p.name,
    pss.total_variants,
    pss.variants_in_stock,
    pss.total_stock,
    pss.min_price,
    pss.max_price,
    COUNT(DISTINCT oi.id) as total_orders,
    COALESCE(SUM(oi.quantity), 0) as total_sold,
    COALESCE(SUM(oi.price * oi.quantity), 0) as total_revenue
FROM products p
LEFT JOIN product_stock_summary pss ON p.id = pss.product_id
LEFT JOIN product_variants pv ON p.id = pv.product_id AND pv.archived_at IS NULL
LEFT JOIN order_items oi ON pv.id = oi.product_variant_id
LEFT JOIN orders o ON oi.order_id = o.id
WHERE p.active = true
  AND ($1::timestamp IS NULL OR o.created_at >= $1)
  AND ($2::timestamp IS NULL OR o.created_at <= $2)
GROUP BY p.id, p.name, pss.total_variants, pss.variants_in_stock, 
         pss.total_stock, pss.min_price, pss.max_price
ORDER BY total_revenue DESC
`

type GetProductPerformanceStatsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
}

type GetProductPerformanceStatsRow struct {
	ID              int32       `db:"id" json:"id"`
	Name            string      `db:"name" json:"name"`
	TotalVariants   interface{} `db:"total_variants" json:"total_variants"`
	VariantsInStock interface{} `db:"variants_in_stock" json:"variants_in_stock"`
	TotalStock      interface{} `db:"total_stock" json:"total_stock"`
	MinPrice        interface{} `db:"min_price" json:"min_price"`
	MaxPrice        interface{} `db:"max_price" json:"max_price"`
	TotalOrders     int64       `db:"total_orders" json:"total_orders"`
	TotalSold       interface{} `db:"total_sold" json:"total_sold"`
	TotalRevenue    interface{} `db:"total_revenue" json:"total_revenue"`
}

// Product analytics and reporting queries
func (q *Queries) GetProductPerformanceStats(ctx context.Context, arg GetProductPerformanceStatsParams) ([]GetProductPerformanceStatsRow, error) {
	rows, err := q.db.Query(ctx, getProductPerformanceStats, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductPerformanceStatsRow{}
	for rows.Next() {
		var i GetProductPerformanceStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TotalVariants,
			&i.VariantsInStock,
			&i.TotalStock,
			&i.MinPrice,
			&i.MaxPrice,
			&i.TotalOrders,
			&i.TotalSold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductWithSummary = `-- name: GetProductWithSummary :one
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_id = $1 AND pss.product_active = true
`

func (q *Queries) GetProductWithSummary(ctx context.Context, productID int32) (ProductStockSummary, error) {
	row := q.db.QueryRow(ctx, getProductWithSummary, productID)
	var i ProductStockSummary
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.ProductActive,
		&i.TotalStock,
		&i.VariantsInStock,
		&i.TotalVariants,
		&i.MinPrice,
		&i.MaxPrice,
		&i.HasStock,
		&i.StockStatus,
		&i.AvailableOptions,
		&i.LastStockUpdate,
	)
	return i, err
}

const getProductsInStock = `-- name: GetProductsInStock :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_active = true AND pss.has_stock = true
ORDER BY pss.total_stock DESC
`

func (q *Queries) GetProductsInStock(ctx context.Context) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, getProductsInStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsWithoutVariants = `-- name: GetProductsWithoutVariants :many
SELECT p.id, p.name, p.description, p.active, p.created_at, p.updated_at
FROM products p
LEFT JOIN product_variants pv ON p.id = pv.product_id AND pv.archived_at IS NULL
WHERE p.active = true AND pv.id IS NULL
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type GetProductsWithoutVariantsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetProductsWithoutVariants(ctx context.Context, arg GetProductsWithoutVariantsParams) ([]Products, error) {
	rows, err := q.db.Query(ctx, getProductsWithoutVariants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many
SELECT 
    p.id,
    p.name,
    SUM(oi.quantity) as total_sold,
    SUM(oi.price * oi.quantity) as total_revenue,
    COUNT(DISTINCT oi.order_id) as order_count
FROM products p
JOIN product_variants pv ON p.id = pv.product_id AND pv.archived_at IS NULL
JOIN order_items oi ON pv.id = oi.product_variant_id
JOIN orders o ON oi.order_id = o.id
WHERE p.active = true
  AND ($1::timestamp IS NULL OR o.created_at >= $1)
  AND ($2::timestamp IS NULL OR o.created_at <= $2)
GROUP BY p.id, p.name
ORDER BY total_sold DESC
LIMIT $3 OFFSET $4
`

type GetTopSellingProductsParams struct {
	Column1 pgtype.Timestamp `db:"column_1" json:"column_1"`
	Column2 pgtype.Timestamp `db:"column_2" json:"column_2"`
	Limit   int32            `db:"limit" json:"limit"`
	Offset  int32            `db:"offset" json:"offset"`
}

type GetTopSellingProductsRow struct {
	ID           int32  `db:"id" json:"id"`
	Name         string `db:"name" json:"name"`
	TotalSold    int64  `db:"total_sold" json:"total_sold"`
	TotalRevenue int64  `db:"total_revenue" json:"total_revenue"`
	OrderCount   int64  `db:"order_count" json:"order_count"`
}

func (q *Queries) GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.Query(ctx, getTopSellingProducts,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopSellingProductsRow{}
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TotalSold,
			&i.TotalRevenue,
			&i.OrderCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllProducts = `-- name: ListAllProducts :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
ORDER BY pss.name
LIMIT $1 OFFSET $2
`

type ListAllProductsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListAllProducts(ctx context.Context, arg ListAllProductsParams) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, listAllProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_active = true
ORDER BY pss.name
`

func (q *Queries) ListProducts(ctx context.Context) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByStatus = `-- name: ListProductsByStatus :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_active = $1
ORDER BY pss.name
LIMIT $2 OFFSET $3
`

type ListProductsByStatusParams struct {
	ProductActive bool  `db:"product_active" json:"product_active"`
	Limit         int32 `db:"limit" json:"limit"`
	Offset        int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListProductsByStatus(ctx context.Context, arg ListProductsByStatusParams) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, listProductsByStatus, arg.ProductActive, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshProductStockSummary = `-- name: RefreshProductStockSummary :exec

REFRESH MATERIALIZED VIEW CONCURRENTLY product_stock_summary
`

// Utility queries
func (q *Queries) RefreshProductStockSummary(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshProductStockSummary)
	return err
}

const searchProducts = `-- name: SearchProducts :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_active = true
  AND (pss.name ILIKE $1 OR pss.description ILIKE $1)
ORDER BY
  CASE WHEN pss.name ILIKE $1 THEN 1 ELSE 2 END,
  pss.name
`

func (q *Queries) SearchProducts(ctx context.Context, name string) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, searchProducts, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsWithOptions = `-- name: SearchProductsWithOptions :many
SELECT 
    pss.product_id,
    pss.name,
    pss.description,
    pss.product_active,
    pss.total_stock,
    pss.variants_in_stock,
    pss.total_variants,
    pss.min_price,
    pss.max_price,
    pss.has_stock,
    pss.stock_status,
    pss.available_options,
    pss.last_stock_update
FROM product_stock_summary pss
WHERE pss.product_active = true
  AND (pss.name ILIKE $1 OR pss.description ILIKE $1 OR pss.available_options::text ILIKE $1)
ORDER BY
  CASE WHEN pss.name ILIKE $1 THEN 1 
       WHEN pss.description ILIKE $1 THEN 2 
       ELSE 3 END,
  pss.name
`

func (q *Queries) SearchProductsWithOptions(ctx context.Context, name string) ([]ProductStockSummary, error) {
	rows, err := q.db.Query(ctx, searchProductsWithOptions, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockSummary{}
	for rows.Next() {
		var i ProductStockSummary
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.ProductActive,
			&i.TotalStock,
			&i.VariantsInStock,
			&i.TotalVariants,
			&i.MinPrice,
			&i.MaxPrice,
			&i.HasStock,
			&i.StockStatus,
			&i.AvailableOptions,
			&i.LastStockUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
  name = COALESCE($2, name),
  description = COALESCE($3, description),
  active = COALESCE($4, active),
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, active, created_at, updated_at
`

type UpdateProductParams struct {
	ID          int32       `db:"id" json:"id"`
	Name        string      `db:"name" json:"name"`
	Description pgtype.Text `db:"description" json:"description"`
	Active      bool        `db:"active" json:"active"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Products, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Active,
	)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
