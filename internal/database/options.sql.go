// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: options.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkOptionUsage = `-- name: CheckOptionUsage :one
SELECT COUNT(*) as usage_count
FROM product_variant_options pvo
JOIN product_variants pv ON pvo.product_variant_id = pv.id
WHERE pvo.product_option_id = $1 AND pv.archived_at IS NULL
`

func (q *Queries) CheckOptionUsage(ctx context.Context, productOptionID int32) (int64, error) {
	row := q.db.QueryRow(ctx, checkOptionUsage, productOptionID)
	var usage_count int64
	err := row.Scan(&usage_count)
	return usage_count, err
}

const checkOptionValueUsage = `-- name: CheckOptionValueUsage :one

SELECT COUNT(*) as usage_count
FROM product_variant_options pvo
JOIN product_variants pv ON pvo.product_variant_id = pv.id
WHERE pvo.product_option_value_id = $1 AND pv.archived_at IS NULL
`

// Validation and integrity queries
func (q *Queries) CheckOptionValueUsage(ctx context.Context, productOptionValueID int32) (int64, error) {
	row := q.db.QueryRow(ctx, checkOptionValueUsage, productOptionValueID)
	var usage_count int64
	err := row.Scan(&usage_count)
	return usage_count, err
}

const createProductOption = `-- name: CreateProductOption :one
INSERT INTO product_options (
    product_id, option_key
) VALUES (
    $1, $2
)
RETURNING id, product_id, option_key, created_at
`

type CreateProductOptionParams struct {
	ProductID int32  `db:"product_id" json:"product_id"`
	OptionKey string `db:"option_key" json:"option_key"`
}

func (q *Queries) CreateProductOption(ctx context.Context, arg CreateProductOptionParams) (ProductOptions, error) {
	row := q.db.QueryRow(ctx, createProductOption, arg.ProductID, arg.OptionKey)
	var i ProductOptions
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OptionKey,
		&i.CreatedAt,
	)
	return i, err
}

const createProductOptionValue = `-- name: CreateProductOptionValue :one
INSERT INTO product_option_values (
    product_option_id, value
) VALUES (
    $1, $2
)
RETURNING id, product_option_id, value, created_at
`

type CreateProductOptionValueParams struct {
	ProductOptionID int32  `db:"product_option_id" json:"product_option_id"`
	Value           string `db:"value" json:"value"`
}

func (q *Queries) CreateProductOptionValue(ctx context.Context, arg CreateProductOptionValueParams) (ProductOptionValues, error) {
	row := q.db.QueryRow(ctx, createProductOptionValue, arg.ProductOptionID, arg.Value)
	var i ProductOptionValues
	err := row.Scan(
		&i.ID,
		&i.ProductOptionID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const createVariantOption = `-- name: CreateVariantOption :one
INSERT INTO product_variant_options (
    product_variant_id, product_option_id, product_option_value_id
) VALUES (
    $1, $2, $3
)
RETURNING id, product_variant_id, product_option_id, product_option_value_id
`

type CreateVariantOptionParams struct {
	ProductVariantID     int32 `db:"product_variant_id" json:"product_variant_id"`
	ProductOptionID      int32 `db:"product_option_id" json:"product_option_id"`
	ProductOptionValueID int32 `db:"product_option_value_id" json:"product_option_value_id"`
}

func (q *Queries) CreateVariantOption(ctx context.Context, arg CreateVariantOptionParams) (ProductVariantOptions, error) {
	row := q.db.QueryRow(ctx, createVariantOption, arg.ProductVariantID, arg.ProductOptionID, arg.ProductOptionValueID)
	var i ProductVariantOptions
	err := row.Scan(
		&i.ID,
		&i.ProductVariantID,
		&i.ProductOptionID,
		&i.ProductOptionValueID,
	)
	return i, err
}

const deleteProductOption = `-- name: DeleteProductOption :exec
DELETE FROM product_options
WHERE id = $1
`

func (q *Queries) DeleteProductOption(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProductOption, id)
	return err
}

const deleteProductOptionValue = `-- name: DeleteProductOptionValue :exec
DELETE FROM product_option_values
WHERE id = $1
`

func (q *Queries) DeleteProductOptionValue(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProductOptionValue, id)
	return err
}

const deleteVariantOption = `-- name: DeleteVariantOption :exec
DELETE FROM product_variant_options
WHERE id = $1
`

func (q *Queries) DeleteVariantOption(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVariantOption, id)
	return err
}

const deleteVariantOptionsByOption = `-- name: DeleteVariantOptionsByOption :exec
DELETE FROM product_variant_options
WHERE product_option_id = $1
`

func (q *Queries) DeleteVariantOptionsByOption(ctx context.Context, productOptionID int32) error {
	_, err := q.db.Exec(ctx, deleteVariantOptionsByOption, productOptionID)
	return err
}

const deleteVariantOptionsByOptionValue = `-- name: DeleteVariantOptionsByOptionValue :exec
DELETE FROM product_variant_options
WHERE product_option_value_id = $1
`

func (q *Queries) DeleteVariantOptionsByOptionValue(ctx context.Context, productOptionValueID int32) error {
	_, err := q.db.Exec(ctx, deleteVariantOptionsByOptionValue, productOptionValueID)
	return err
}

const deleteVariantOptionsByVariant = `-- name: DeleteVariantOptionsByVariant :exec
DELETE FROM product_variant_options
WHERE product_variant_id = $1
`

func (q *Queries) DeleteVariantOptionsByVariant(ctx context.Context, productVariantID int32) error {
	_, err := q.db.Exec(ctx, deleteVariantOptionsByVariant, productVariantID)
	return err
}

const getAvailableOptionValues = `-- name: GetAvailableOptionValues :many
SELECT DISTINCT
    po.id as option_id,
    po.option_key,
    pov.id as value_id,
    pov.value
FROM product_options po
JOIN product_option_values pov ON po.id = pov.product_option_id
JOIN product_variant_options pvo ON pov.id = pvo.product_option_value_id
JOIN product_variants pv ON pvo.product_variant_id = pv.id
WHERE po.product_id = $1 
  AND pv.active = true 
  AND pv.archived_at IS NULL
ORDER BY po.option_key ASC, pov.value ASC
`

type GetAvailableOptionValuesRow struct {
	OptionID  int32  `db:"option_id" json:"option_id"`
	OptionKey string `db:"option_key" json:"option_key"`
	ValueID   int32  `db:"value_id" json:"value_id"`
	Value     string `db:"value" json:"value"`
}

func (q *Queries) GetAvailableOptionValues(ctx context.Context, productID int32) ([]GetAvailableOptionValuesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableOptionValues, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableOptionValuesRow{}
	for rows.Next() {
		var i GetAvailableOptionValuesRow
		if err := rows.Scan(
			&i.OptionID,
			&i.OptionKey,
			&i.ValueID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionCombinationsInStock = `-- name: GetOptionCombinationsInStock :many
SELECT 
    pv.id as variant_id,
    pv.stock,
    json_agg(
        json_build_object(
            'option_id', po.id,
            'option_key', po.option_key,
            'value_id', pov.id,
            'value', pov.value
        ) ORDER BY po.option_key
    ) as option_combination
FROM product_variants pv
JOIN product_variant_options pvo ON pv.id = pvo.product_variant_id
JOIN product_options po ON pvo.product_option_id = po.id
JOIN product_option_values pov ON pvo.product_option_value_id = pov.id
WHERE po.product_id = $1
  AND pv.active = true
  AND pv.archived_at IS NULL
  AND pv.stock > 0
GROUP BY pv.id, pv.stock
ORDER BY pv.stock DESC
`

type GetOptionCombinationsInStockRow struct {
	VariantID         int32  `db:"variant_id" json:"variant_id"`
	Stock             int32  `db:"stock" json:"stock"`
	OptionCombination []byte `db:"option_combination" json:"option_combination"`
}

func (q *Queries) GetOptionCombinationsInStock(ctx context.Context, productID int32) ([]GetOptionCombinationsInStockRow, error) {
	rows, err := q.db.Query(ctx, getOptionCombinationsInStock, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOptionCombinationsInStockRow{}
	for rows.Next() {
		var i GetOptionCombinationsInStockRow
		if err := rows.Scan(&i.VariantID, &i.Stock, &i.OptionCombination); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionPopularity = `-- name: GetOptionPopularity :many

SELECT 
    po.id,
    po.option_key,
    pov.id as value_id,
    pov.value,
    COUNT(DISTINCT pv.id) as variant_count,
    COUNT(DISTINCT oi.id) as order_count,
    COALESCE(SUM(oi.quantity), 0) as total_sold
FROM product_options po
JOIN product_option_values pov ON po.id = pov.product_option_id
LEFT JOIN product_variant_options pvo ON pov.id = pvo.product_option_value_id
LEFT JOIN product_variants pv ON pvo.product_variant_id = pv.id AND pv.archived_at IS NULL
LEFT JOIN order_items oi ON pv.id = oi.product_variant_id
LEFT JOIN orders o ON oi.order_id = o.id
WHERE po.product_id = $1
  AND ($2::timestamp IS NULL OR o.created_at >= $2)
  AND ($3::timestamp IS NULL OR o.created_at <= $3)
GROUP BY po.id, po.option_key, pov.id, pov.value
ORDER BY po.option_key ASC, total_sold DESC
`

type GetOptionPopularityParams struct {
	ProductID int32            `db:"product_id" json:"product_id"`
	StartDate pgtype.Timestamp `db:"start_date" json:"start_date"`
	EndDate   pgtype.Timestamp `db:"end_date" json:"end_date"`
}

type GetOptionPopularityRow struct {
	ID           int32       `db:"id" json:"id"`
	OptionKey    string      `db:"option_key" json:"option_key"`
	ValueID      int32       `db:"value_id" json:"value_id"`
	Value        string      `db:"value" json:"value"`
	VariantCount int64       `db:"variant_count" json:"variant_count"`
	OrderCount   int64       `db:"order_count" json:"order_count"`
	TotalSold    interface{} `db:"total_sold" json:"total_sold"`
}

// Option analytics
func (q *Queries) GetOptionPopularity(ctx context.Context, arg GetOptionPopularityParams) ([]GetOptionPopularityRow, error) {
	rows, err := q.db.Query(ctx, getOptionPopularity, arg.ProductID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOptionPopularityRow{}
	for rows.Next() {
		var i GetOptionPopularityRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionKey,
			&i.ValueID,
			&i.Value,
			&i.VariantCount,
			&i.OrderCount,
			&i.TotalSold,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedOptionValues = `-- name: GetOrphanedOptionValues :many
SELECT pov.id, pov.product_option_id, pov.value, pov.created_at
FROM product_option_values pov
LEFT JOIN product_variant_options pvo ON pov.id = pvo.product_option_value_id
LEFT JOIN product_variants pv ON pvo.product_variant_id = pv.id AND pv.archived_at IS NULL
WHERE pv.id IS NULL
`

func (q *Queries) GetOrphanedOptionValues(ctx context.Context) ([]ProductOptionValues, error) {
	rows, err := q.db.Query(ctx, getOrphanedOptionValues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOptionValues{}
	for rows.Next() {
		var i ProductOptionValues
		if err := rows.Scan(
			&i.ID,
			&i.ProductOptionID,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedOptions = `-- name: GetOrphanedOptions :many
SELECT po.id, po.product_id, po.option_key, po.created_at
FROM product_options po
LEFT JOIN product_option_values pov ON po.id = pov.product_option_id
WHERE pov.id IS NULL
`

func (q *Queries) GetOrphanedOptions(ctx context.Context) ([]ProductOptions, error) {
	rows, err := q.db.Query(ctx, getOrphanedOptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOptions{}
	for rows.Next() {
		var i ProductOptions
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OptionKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductOption = `-- name: GetProductOption :one


SELECT id, product_id, option_key, created_at
FROM product_options
WHERE id = $1
`

// internal/database/queries/options.sql
// Product options and option values queries
// Product Options CRUD
func (q *Queries) GetProductOption(ctx context.Context, id int32) (ProductOptions, error) {
	row := q.db.QueryRow(ctx, getProductOption, id)
	var i ProductOptions
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OptionKey,
		&i.CreatedAt,
	)
	return i, err
}

const getProductOptionByKey = `-- name: GetProductOptionByKey :one
SELECT id, product_id, option_key, created_at
FROM product_options
WHERE product_id = $1 AND option_key = $2
`

type GetProductOptionByKeyParams struct {
	ProductID int32  `db:"product_id" json:"product_id"`
	OptionKey string `db:"option_key" json:"option_key"`
}

func (q *Queries) GetProductOptionByKey(ctx context.Context, arg GetProductOptionByKeyParams) (ProductOptions, error) {
	row := q.db.QueryRow(ctx, getProductOptionByKey, arg.ProductID, arg.OptionKey)
	var i ProductOptions
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OptionKey,
		&i.CreatedAt,
	)
	return i, err
}

const getProductOptionValue = `-- name: GetProductOptionValue :one

SELECT id, product_option_id, value, created_at
FROM product_option_values
WHERE id = $1
`

// Product Option Values CRUD
func (q *Queries) GetProductOptionValue(ctx context.Context, id int32) (ProductOptionValues, error) {
	row := q.db.QueryRow(ctx, getProductOptionValue, id)
	var i ProductOptionValues
	err := row.Scan(
		&i.ID,
		&i.ProductOptionID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getProductOptionValueByValue = `-- name: GetProductOptionValueByValue :one
SELECT id, product_option_id, value, created_at
FROM product_option_values
WHERE product_option_id = $1 AND value = $2
`

type GetProductOptionValueByValueParams struct {
	ProductOptionID int32  `db:"product_option_id" json:"product_option_id"`
	Value           string `db:"value" json:"value"`
}

func (q *Queries) GetProductOptionValueByValue(ctx context.Context, arg GetProductOptionValueByValueParams) (ProductOptionValues, error) {
	row := q.db.QueryRow(ctx, getProductOptionValueByValue, arg.ProductOptionID, arg.Value)
	var i ProductOptionValues
	err := row.Scan(
		&i.ID,
		&i.ProductOptionID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getProductOptionValuesByOption = `-- name: GetProductOptionValuesByOption :many
SELECT id, product_option_id, value, created_at
FROM product_option_values
WHERE product_option_id = $1
ORDER BY value ASC
`

func (q *Queries) GetProductOptionValuesByOption(ctx context.Context, productOptionID int32) ([]ProductOptionValues, error) {
	rows, err := q.db.Query(ctx, getProductOptionValuesByOption, productOptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOptionValues{}
	for rows.Next() {
		var i ProductOptionValues
		if err := rows.Scan(
			&i.ID,
			&i.ProductOptionID,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductOptionValuesByProduct = `-- name: GetProductOptionValuesByProduct :many
SELECT 
    pov.id, pov.product_option_id, pov.value, pov.created_at,
    po.option_key
FROM product_option_values pov
JOIN product_options po ON pov.product_option_id = po.id
WHERE po.product_id = $1
ORDER BY po.option_key ASC, pov.value ASC
`

type GetProductOptionValuesByProductRow struct {
	ID              int32     `db:"id" json:"id"`
	ProductOptionID int32     `db:"product_option_id" json:"product_option_id"`
	Value           string    `db:"value" json:"value"`
	CreatedAt       time.Time `db:"created_at" json:"created_at"`
	OptionKey       string    `db:"option_key" json:"option_key"`
}

func (q *Queries) GetProductOptionValuesByProduct(ctx context.Context, productID int32) ([]GetProductOptionValuesByProductRow, error) {
	rows, err := q.db.Query(ctx, getProductOptionValuesByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductOptionValuesByProductRow{}
	for rows.Next() {
		var i GetProductOptionValuesByProductRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductOptionID,
			&i.Value,
			&i.CreatedAt,
			&i.OptionKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductOptions = `-- name: GetProductOptions :many
SELECT id, product_id, option_key, created_at
FROM product_options
WHERE product_id = $1
ORDER BY option_key ASC
`

func (q *Queries) GetProductOptions(ctx context.Context, productID int32) ([]ProductOptions, error) {
	rows, err := q.db.Query(ctx, getProductOptions, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOptions{}
	for rows.Next() {
		var i ProductOptions
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OptionKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantByOptionCombination = `-- name: GetVariantByOptionCombination :one

SELECT 
    pv.id, pv.product_id, pv.name, pv.price, pv.stock, pv.active, 
    pv.is_subscription, pv.archived_at, pv.created_at, pv.updated_at,
    pv.stripe_product_id, pv.stripe_price_onetime_id, pv.stripe_price_14day_id,
    pv.stripe_price_21day_id, pv.stripe_price_30day_id, pv.stripe_price_60day_id,
    pv.options_display
FROM product_variants pv
WHERE pv.product_id = $1 
  AND pv.archived_at IS NULL
  AND NOT EXISTS (
    SELECT 1 
    FROM product_variant_options pvo1
    WHERE pvo1.product_variant_id = pv.id
    AND pvo1.product_option_value_id != ANY($2::int[])
  )
  AND (
    SELECT COUNT(*) 
    FROM product_variant_options pvo2
    WHERE pvo2.product_variant_id = pv.id
  ) = array_length($2::int[], 1)
`

type GetVariantByOptionCombinationParams struct {
	ProductID int32   `db:"product_id" json:"product_id"`
	Column2   []int32 `db:"column_2" json:"column_2"`
}

// Complex option queries for variant management
func (q *Queries) GetVariantByOptionCombination(ctx context.Context, arg GetVariantByOptionCombinationParams) (ProductVariants, error) {
	row := q.db.QueryRow(ctx, getVariantByOptionCombination, arg.ProductID, arg.Column2)
	var i ProductVariants
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.IsSubscription,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeProductID,
		&i.StripePriceOnetimeID,
		&i.StripePrice14dayID,
		&i.StripePrice21dayID,
		&i.StripePrice30dayID,
		&i.StripePrice60dayID,
		&i.OptionsDisplay,
	)
	return i, err
}

const getVariantOption = `-- name: GetVariantOption :one

SELECT id, product_variant_id, product_option_id, product_option_value_id
FROM product_variant_options
WHERE id = $1
`

// Product Variant Options (Junction Table) CRUD
func (q *Queries) GetVariantOption(ctx context.Context, id int32) (ProductVariantOptions, error) {
	row := q.db.QueryRow(ctx, getVariantOption, id)
	var i ProductVariantOptions
	err := row.Scan(
		&i.ID,
		&i.ProductVariantID,
		&i.ProductOptionID,
		&i.ProductOptionValueID,
	)
	return i, err
}

const getVariantOptionsByProduct = `-- name: GetVariantOptionsByProduct :many
SELECT 
    pvo.id, pvo.product_variant_id, pvo.product_option_id, pvo.product_option_value_id,
    po.option_key,
    pov.value,
    pv.name as variant_name,
    pv.price as variant_price
FROM product_variant_options pvo
JOIN product_options po ON pvo.product_option_id = po.id
JOIN product_option_values pov ON pvo.product_option_value_id = pov.id
JOIN product_variants pv ON pvo.product_variant_id = pv.id
WHERE po.product_id = $1 AND pv.archived_at IS NULL
ORDER BY pv.name ASC, po.option_key ASC
`

type GetVariantOptionsByProductRow struct {
	ID                   int32  `db:"id" json:"id"`
	ProductVariantID     int32  `db:"product_variant_id" json:"product_variant_id"`
	ProductOptionID      int32  `db:"product_option_id" json:"product_option_id"`
	ProductOptionValueID int32  `db:"product_option_value_id" json:"product_option_value_id"`
	OptionKey            string `db:"option_key" json:"option_key"`
	Value                string `db:"value" json:"value"`
	VariantName          string `db:"variant_name" json:"variant_name"`
	VariantPrice         int32  `db:"variant_price" json:"variant_price"`
}

func (q *Queries) GetVariantOptionsByProduct(ctx context.Context, productID int32) ([]GetVariantOptionsByProductRow, error) {
	rows, err := q.db.Query(ctx, getVariantOptionsByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVariantOptionsByProductRow{}
	for rows.Next() {
		var i GetVariantOptionsByProductRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductVariantID,
			&i.ProductOptionID,
			&i.ProductOptionValueID,
			&i.OptionKey,
			&i.Value,
			&i.VariantName,
			&i.VariantPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantOptionsByVariant = `-- name: GetVariantOptionsByVariant :many
SELECT 
    pvo.id, pvo.product_variant_id, pvo.product_option_id, pvo.product_option_value_id,
    po.option_key,
    pov.value
FROM product_variant_options pvo
JOIN product_options po ON pvo.product_option_id = po.id
JOIN product_option_values pov ON pvo.product_option_value_id = pov.id
WHERE pvo.product_variant_id = $1
ORDER BY po.option_key ASC
`

type GetVariantOptionsByVariantRow struct {
	ID                   int32  `db:"id" json:"id"`
	ProductVariantID     int32  `db:"product_variant_id" json:"product_variant_id"`
	ProductOptionID      int32  `db:"product_option_id" json:"product_option_id"`
	ProductOptionValueID int32  `db:"product_option_value_id" json:"product_option_value_id"`
	OptionKey            string `db:"option_key" json:"option_key"`
	Value                string `db:"value" json:"value"`
}

func (q *Queries) GetVariantOptionsByVariant(ctx context.Context, productVariantID int32) ([]GetVariantOptionsByVariantRow, error) {
	rows, err := q.db.Query(ctx, getVariantOptionsByVariant, productVariantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVariantOptionsByVariantRow{}
	for rows.Next() {
		var i GetVariantOptionsByVariantRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductVariantID,
			&i.ProductOptionID,
			&i.ProductOptionValueID,
			&i.OptionKey,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantsWithOptionValues = `-- name: GetVariantsWithOptionValues :many
SELECT 
    pv.id as variant_id,
    pv.name as variant_name,
    pv.price,
    pv.stock,
    pv.active,
    json_agg(
        json_build_object(
            'option_id', po.id,
            'option_key', po.option_key,
            'value_id', pov.id,
            'value', pov.value
        ) ORDER BY po.option_key
    ) as options
FROM product_variants pv
LEFT JOIN product_variant_options pvo ON pv.id = pvo.product_variant_id
LEFT JOIN product_options po ON pvo.product_option_id = po.id
LEFT JOIN product_option_values pov ON pvo.product_option_value_id = pov.id
WHERE pv.product_id = $1 AND pv.archived_at IS NULL
GROUP BY pv.id, pv.name, pv.price, pv.stock, pv.active
ORDER BY pv.price ASC, pv.name ASC
`

type GetVariantsWithOptionValuesRow struct {
	VariantID   int32  `db:"variant_id" json:"variant_id"`
	VariantName string `db:"variant_name" json:"variant_name"`
	Price       int32  `db:"price" json:"price"`
	Stock       int32  `db:"stock" json:"stock"`
	Active      bool   `db:"active" json:"active"`
	Options     []byte `db:"options" json:"options"`
}

func (q *Queries) GetVariantsWithOptionValues(ctx context.Context, productID int32) ([]GetVariantsWithOptionValuesRow, error) {
	rows, err := q.db.Query(ctx, getVariantsWithOptionValues, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVariantsWithOptionValuesRow{}
	for rows.Next() {
		var i GetVariantsWithOptionValuesRow
		if err := rows.Scan(
			&i.VariantID,
			&i.VariantName,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductOption = `-- name: UpdateProductOption :one
UPDATE product_options
SET
    option_key = $2
WHERE id = $1
RETURNING id, product_id, option_key, created_at
`

type UpdateProductOptionParams struct {
	ID        int32  `db:"id" json:"id"`
	OptionKey string `db:"option_key" json:"option_key"`
}

func (q *Queries) UpdateProductOption(ctx context.Context, arg UpdateProductOptionParams) (ProductOptions, error) {
	row := q.db.QueryRow(ctx, updateProductOption, arg.ID, arg.OptionKey)
	var i ProductOptions
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OptionKey,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductOptionValue = `-- name: UpdateProductOptionValue :one
UPDATE product_option_values
SET
    value = $2
WHERE id = $1
RETURNING id, product_option_id, value, created_at
`

type UpdateProductOptionValueParams struct {
	ID    int32  `db:"id" json:"id"`
	Value string `db:"value" json:"value"`
}

func (q *Queries) UpdateProductOptionValue(ctx context.Context, arg UpdateProductOptionValueParams) (ProductOptionValues, error) {
	row := q.db.QueryRow(ctx, updateProductOptionValue, arg.ID, arg.Value)
	var i ProductOptionValues
	err := row.Scan(
		&i.ID,
		&i.ProductOptionID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}
