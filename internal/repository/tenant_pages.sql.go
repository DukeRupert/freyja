// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenant_pages.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTenantPage = `-- name: CreateTenantPage :one
INSERT INTO tenant_pages (
    tenant_id,
    slug,
    title,
    content,
    meta_description,
    last_updated_label,
    is_published
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, tenant_id, slug, title, content, meta_description, last_updated_label, is_published, created_at, updated_at
`

type CreateTenantPageParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	Slug             string      `json:"slug"`
	Title            string      `json:"title"`
	Content          string      `json:"content"`
	MetaDescription  pgtype.Text `json:"meta_description"`
	LastUpdatedLabel pgtype.Text `json:"last_updated_label"`
	IsPublished      bool        `json:"is_published"`
}

// Create a new page
func (q *Queries) CreateTenantPage(ctx context.Context, arg CreateTenantPageParams) (TenantPage, error) {
	row := q.db.QueryRow(ctx, createTenantPage,
		arg.TenantID,
		arg.Slug,
		arg.Title,
		arg.Content,
		arg.MetaDescription,
		arg.LastUpdatedLabel,
		arg.IsPublished,
	)
	var i TenantPage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Slug,
		&i.Title,
		&i.Content,
		&i.MetaDescription,
		&i.LastUpdatedLabel,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTenantPage = `-- name: DeleteTenantPage :exec
DELETE FROM tenant_pages
WHERE tenant_id = $1 AND slug = $2
`

type DeleteTenantPageParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Slug     string      `json:"slug"`
}

// Delete a page
func (q *Queries) DeleteTenantPage(ctx context.Context, arg DeleteTenantPageParams) error {
	_, err := q.db.Exec(ctx, deleteTenantPage, arg.TenantID, arg.Slug)
	return err
}

const getPublishedTenantPage = `-- name: GetPublishedTenantPage :one
SELECT id, tenant_id, slug, title, content, meta_description, last_updated_label, is_published, created_at, updated_at
FROM tenant_pages
WHERE tenant_id = $1 AND slug = $2 AND is_published = true
`

type GetPublishedTenantPageParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Slug     string      `json:"slug"`
}

// Get a published page by tenant and slug (for storefront)
func (q *Queries) GetPublishedTenantPage(ctx context.Context, arg GetPublishedTenantPageParams) (TenantPage, error) {
	row := q.db.QueryRow(ctx, getPublishedTenantPage, arg.TenantID, arg.Slug)
	var i TenantPage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Slug,
		&i.Title,
		&i.Content,
		&i.MetaDescription,
		&i.LastUpdatedLabel,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantPage = `-- name: GetTenantPage :one
SELECT id, tenant_id, slug, title, content, meta_description, last_updated_label, is_published, created_at, updated_at
FROM tenant_pages
WHERE tenant_id = $1 AND slug = $2
`

type GetTenantPageParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Slug     string      `json:"slug"`
}

// Get a single page by tenant and slug
func (q *Queries) GetTenantPage(ctx context.Context, arg GetTenantPageParams) (TenantPage, error) {
	row := q.db.QueryRow(ctx, getTenantPage, arg.TenantID, arg.Slug)
	var i TenantPage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Slug,
		&i.Title,
		&i.Content,
		&i.MetaDescription,
		&i.LastUpdatedLabel,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTenantPages = `-- name: ListTenantPages :many
SELECT id, tenant_id, slug, title, content, meta_description, last_updated_label, is_published, created_at, updated_at
FROM tenant_pages
WHERE tenant_id = $1
ORDER BY slug
`

// List all pages for a tenant (for admin)
func (q *Queries) ListTenantPages(ctx context.Context, tenantID pgtype.UUID) ([]TenantPage, error) {
	rows, err := q.db.Query(ctx, listTenantPages, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TenantPage{}
	for rows.Next() {
		var i TenantPage
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Slug,
			&i.Title,
			&i.Content,
			&i.MetaDescription,
			&i.LastUpdatedLabel,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tenantPageExists = `-- name: TenantPageExists :one
SELECT EXISTS(
    SELECT 1 FROM tenant_pages WHERE tenant_id = $1 AND slug = $2
) AS exists
`

type TenantPageExistsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Slug     string      `json:"slug"`
}

// Check if a page exists
func (q *Queries) TenantPageExists(ctx context.Context, arg TenantPageExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, tenantPageExists, arg.TenantID, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTenantPage = `-- name: UpdateTenantPage :one
UPDATE tenant_pages
SET
    title = $3,
    content = $4,
    meta_description = $5,
    last_updated_label = $6,
    is_published = $7
WHERE tenant_id = $1 AND slug = $2
RETURNING id, tenant_id, slug, title, content, meta_description, last_updated_label, is_published, created_at, updated_at
`

type UpdateTenantPageParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	Slug             string      `json:"slug"`
	Title            string      `json:"title"`
	Content          string      `json:"content"`
	MetaDescription  pgtype.Text `json:"meta_description"`
	LastUpdatedLabel pgtype.Text `json:"last_updated_label"`
	IsPublished      bool        `json:"is_published"`
}

// Update an existing page
func (q *Queries) UpdateTenantPage(ctx context.Context, arg UpdateTenantPageParams) (TenantPage, error) {
	row := q.db.QueryRow(ctx, updateTenantPage,
		arg.TenantID,
		arg.Slug,
		arg.Title,
		arg.Content,
		arg.MetaDescription,
		arg.LastUpdatedLabel,
		arg.IsPublished,
	)
	var i TenantPage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Slug,
		&i.Title,
		&i.Content,
		&i.MetaDescription,
		&i.LastUpdatedLabel,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertTenantPage = `-- name: UpsertTenantPage :one
INSERT INTO tenant_pages (
    tenant_id,
    slug,
    title,
    content,
    meta_description,
    last_updated_label,
    is_published
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (tenant_id, slug) DO UPDATE SET
    title = EXCLUDED.title,
    content = EXCLUDED.content,
    meta_description = EXCLUDED.meta_description,
    last_updated_label = EXCLUDED.last_updated_label,
    is_published = EXCLUDED.is_published
RETURNING id, tenant_id, slug, title, content, meta_description, last_updated_label, is_published, created_at, updated_at
`

type UpsertTenantPageParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	Slug             string      `json:"slug"`
	Title            string      `json:"title"`
	Content          string      `json:"content"`
	MetaDescription  pgtype.Text `json:"meta_description"`
	LastUpdatedLabel pgtype.Text `json:"last_updated_label"`
	IsPublished      bool        `json:"is_published"`
}

// Create or update a page (useful for seeding defaults)
func (q *Queries) UpsertTenantPage(ctx context.Context, arg UpsertTenantPageParams) (TenantPage, error) {
	row := q.db.QueryRow(ctx, upsertTenantPage,
		arg.TenantID,
		arg.Slug,
		arg.Title,
		arg.Content,
		arg.MetaDescription,
		arg.LastUpdatedLabel,
		arg.IsPublished,
	)
	var i TenantPage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Slug,
		&i.Title,
		&i.Content,
		&i.MetaDescription,
		&i.LastUpdatedLabel,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
