// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAddress = `-- name: CreateAddress :one
INSERT INTO addresses (
    tenant_id,
    address_type,
    full_name,
    company,
    address_line1,
    address_line2,
    city,
    state,
    postal_code,
    country,
    phone
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, tenant_id, full_name, company, address_line1, address_line2, city, state, postal_code, country, phone, email, address_type, is_validated, validation_metadata, created_at, updated_at
`

type CreateAddressParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	AddressType  string      `json:"address_type"`
	FullName     pgtype.Text `json:"full_name"`
	Company      pgtype.Text `json:"company"`
	AddressLine1 string      `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
	City         string      `json:"city"`
	State        string      `json:"state"`
	PostalCode   string      `json:"postal_code"`
	Country      string      `json:"country"`
	Phone        pgtype.Text `json:"phone"`
}

// Creates a new address record for shipping or billing
// Returns complete address with generated ID
func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, createAddress,
		arg.TenantID,
		arg.AddressType,
		arg.FullName,
		arg.Company,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.AddressType,
		&i.IsValidated,
		&i.ValidationMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createBillingCustomer = `-- name: CreateBillingCustomer :one
INSERT INTO billing_customers (
    tenant_id,
    user_id,
    provider,
    provider_customer_id
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (user_id, provider) DO UPDATE
SET updated_at = NOW()
RETURNING id, tenant_id, user_id, provider, provider_customer_id, metadata, created_at, updated_at
`

type CreateBillingCustomerParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	UserID             pgtype.UUID `json:"user_id"`
	Provider           string      `json:"provider"`
	ProviderCustomerID string      `json:"provider_customer_id"`
}

// Creates a billing customer record (links to Stripe customer)
// This is for tracking payment method details
func (q *Queries) CreateBillingCustomer(ctx context.Context, arg CreateBillingCustomerParams) (BillingCustomer, error) {
	row := q.db.QueryRow(ctx, createBillingCustomer,
		arg.TenantID,
		arg.UserID,
		arg.Provider,
		arg.ProviderCustomerID,
	)
	var i BillingCustomer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Provider,
		&i.ProviderCustomerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    tenant_id,
    cart_id,
    user_id,
    order_number,
    order_type,
    status,
    subtotal_cents,
    shipping_cents,
    tax_cents,
    total_cents,
    currency,
    shipping_address_id,
    billing_address_id,
    customer_notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, tenant_id, user_id, order_number, order_type, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, currency, payment_id, payment_status, shipping_address_id, billing_address_id, shipping_method, shipping_carrier, customer_notes, internal_notes, fulfillment_status, cart_id, subscription_id, metadata, paid_at, shipped_at, delivered_at, cancelled_at, created_at, updated_at
`

type CreateOrderParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	CartID            pgtype.UUID `json:"cart_id"`
	UserID            pgtype.UUID `json:"user_id"`
	OrderNumber       string      `json:"order_number"`
	OrderType         string      `json:"order_type"`
	Status            string      `json:"status"`
	SubtotalCents     int32       `json:"subtotal_cents"`
	ShippingCents     int32       `json:"shipping_cents"`
	TaxCents          int32       `json:"tax_cents"`
	TotalCents        int32       `json:"total_cents"`
	Currency          string      `json:"currency"`
	ShippingAddressID pgtype.UUID `json:"shipping_address_id"`
	BillingAddressID  pgtype.UUID `json:"billing_address_id"`
	CustomerNotes     pgtype.Text `json:"customer_notes"`
}

// Creates a new order record with all required fields
// Returns the complete order with generated ID and timestamps
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.TenantID,
		arg.CartID,
		arg.UserID,
		arg.OrderNumber,
		arg.OrderType,
		arg.Status,
		arg.SubtotalCents,
		arg.ShippingCents,
		arg.TaxCents,
		arg.TotalCents,
		arg.Currency,
		arg.ShippingAddressID,
		arg.BillingAddressID,
		arg.CustomerNotes,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    tenant_id,
    order_id,
    product_sku_id,
    product_name,
    sku,
    variant_description,
    quantity,
    unit_price_cents,
    total_price_cents
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, tenant_id, order_id, product_sku_id, product_name, sku, variant_description, quantity, unit_price_cents, total_price_cents, fulfillment_status, metadata, created_at, updated_at
`

type CreateOrderItemParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	OrderID            pgtype.UUID `json:"order_id"`
	ProductSkuID       pgtype.UUID `json:"product_sku_id"`
	ProductName        string      `json:"product_name"`
	Sku                string      `json:"sku"`
	VariantDescription pgtype.Text `json:"variant_description"`
	Quantity           int32       `json:"quantity"`
	UnitPriceCents     int32       `json:"unit_price_cents"`
	TotalPriceCents    int32       `json:"total_price_cents"`
}

// Creates an order line item linked to a specific order
// Captures product state at time of purchase
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.TenantID,
		arg.OrderID,
		arg.ProductSkuID,
		arg.ProductName,
		arg.Sku,
		arg.VariantDescription,
		arg.Quantity,
		arg.UnitPriceCents,
		arg.TotalPriceCents,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.ProductSkuID,
		&i.ProductName,
		&i.Sku,
		&i.VariantDescription,
		&i.Quantity,
		&i.UnitPriceCents,
		&i.TotalPriceCents,
		&i.FulfillmentStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    tenant_id,
    billing_customer_id,
    provider,
    provider_payment_id,
    amount_cents,
    currency,
    status,
    payment_method_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, tenant_id, billing_customer_id, provider, provider_payment_id, amount_cents, currency, status, payment_method_id, failure_code, failure_message, refunded_amount_cents, metadata, succeeded_at, failed_at, refunded_at, created_at, updated_at
`

type CreatePaymentParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	BillingCustomerID pgtype.UUID `json:"billing_customer_id"`
	Provider          string      `json:"provider"`
	ProviderPaymentID string      `json:"provider_payment_id"`
	AmountCents       int32       `json:"amount_cents"`
	Currency          string      `json:"currency"`
	Status            string      `json:"status"`
	PaymentMethodID   pgtype.UUID `json:"payment_method_id"`
}

// Records a payment transaction linked to an order
// Includes Stripe payment intent ID for reconciliation
func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.TenantID,
		arg.BillingCustomerID,
		arg.Provider,
		arg.ProviderPaymentID,
		arg.AmountCents,
		arg.Currency,
		arg.Status,
		arg.PaymentMethodID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.FailureCode,
		&i.FailureMessage,
		&i.RefundedAmountCents,
		&i.Metadata,
		&i.SucceededAt,
		&i.FailedAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementSKUStock = `-- name: DecrementSKUStock :exec
UPDATE product_skus
SET inventory_quantity = inventory_quantity - $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
  AND inventory_quantity >= $3
`

type DecrementSKUStockParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	ID                pgtype.UUID `json:"id"`
	InventoryQuantity int32       `json:"inventory_quantity"`
}

// Decrements inventory for a SKU after order placement
// Uses optimistic locking to prevent overselling
func (q *Queries) DecrementSKUStock(ctx context.Context, arg DecrementSKUStockParams) error {
	_, err := q.db.Exec(ctx, decrementSKUStock, arg.TenantID, arg.ID, arg.InventoryQuantity)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT id, tenant_id, user_id, order_number, order_type, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, currency, payment_id, payment_status, shipping_address_id, billing_address_id, shipping_method, shipping_carrier, customer_notes, internal_notes, fulfillment_status, cart_id, subscription_id, metadata, paid_at, shipped_at, delivered_at, cancelled_at, created_at, updated_at FROM orders
WHERE tenant_id = $1
  AND id = $2
LIMIT 1
`

type GetOrderParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Retrieves a single order by ID with tenant scoping
func (q *Queries) GetOrder(ctx context.Context, arg GetOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, arg.TenantID, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByNumber = `-- name: GetOrderByNumber :one
SELECT id, tenant_id, user_id, order_number, order_type, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, currency, payment_id, payment_status, shipping_address_id, billing_address_id, shipping_method, shipping_carrier, customer_notes, internal_notes, fulfillment_status, cart_id, subscription_id, metadata, paid_at, shipped_at, delivered_at, cancelled_at, created_at, updated_at FROM orders
WHERE tenant_id = $1
  AND order_number = $2
LIMIT 1
`

type GetOrderByNumberParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	OrderNumber string      `json:"order_number"`
}

// Retrieves a single order by order number with tenant scoping
// Order numbers are unique per tenant
func (q *Queries) GetOrderByNumber(ctx context.Context, arg GetOrderByNumberParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByNumber, arg.TenantID, arg.OrderNumber)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByPaymentIntentID = `-- name: GetOrderByPaymentIntentID :one
SELECT o.id, o.tenant_id, o.user_id, o.order_number, o.order_type, o.status, o.subtotal_cents, o.tax_cents, o.shipping_cents, o.discount_cents, o.total_cents, o.currency, o.payment_id, o.payment_status, o.shipping_address_id, o.billing_address_id, o.shipping_method, o.shipping_carrier, o.customer_notes, o.internal_notes, o.fulfillment_status, o.cart_id, o.subscription_id, o.metadata, o.paid_at, o.shipped_at, o.delivered_at, o.cancelled_at, o.created_at, o.updated_at FROM orders o
INNER JOIN payments p ON p.order_id = o.id AND p.tenant_id = o.tenant_id
WHERE o.tenant_id = $1
  AND p.provider_payment_id = $2
LIMIT 1
`

type GetOrderByPaymentIntentIDParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	ProviderPaymentID string      `json:"provider_payment_id"`
}

// Idempotency check: Returns existing order if payment intent was already processed
// This prevents duplicate order creation from webhook retries
func (q *Queries) GetOrderByPaymentIntentID(ctx context.Context, arg GetOrderByPaymentIntentIDParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByPaymentIntentID, arg.TenantID, arg.ProviderPaymentID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCartStatus = `-- name: UpdateCartStatus :exec

UPDATE carts
SET status = $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateCartStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
	Status   string      `json:"status"`
}

// Ensures sufficient stock
// Marks cart as converted to order
// Prevents duplicate order creation from same cart
func (q *Queries) UpdateCartStatus(ctx context.Context, arg UpdateCartStatusParams) error {
	_, err := q.db.Exec(ctx, updateCartStatus, arg.TenantID, arg.ID, arg.Status)
	return err
}
