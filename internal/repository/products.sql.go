// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPrimaryImage = `-- name: GetPrimaryImage :one
SELECT
    id,
    tenant_id,
    product_id,
    url,
    alt_text,
    width,
    height,
    file_size,
    sort_order,
    is_primary,
    created_at
FROM product_images
WHERE product_id = $1
  AND is_primary = TRUE
LIMIT 1
`

// Get the primary image for a product
func (q *Queries) GetPrimaryImage(ctx context.Context, productID pgtype.UUID) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getPrimaryImage, productID)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.Url,
		&i.AltText,
		&i.Width,
		&i.Height,
		&i.FileSize,
		&i.SortOrder,
		&i.IsPrimary,
		&i.CreatedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT
    id,
    tenant_id,
    name,
    slug,
    description,
    short_description,
    origin,
    region,
    producer,
    process,
    roast_level,
    elevation_min,
    elevation_max,
    variety,
    harvest_year,
    tasting_notes,
    status,
    visibility,
    meta_title,
    meta_description,
    sort_order,
    created_at,
    updated_at
FROM products
WHERE tenant_id = $1
  AND slug = $2
  AND status = 'active'
LIMIT 1
`

type GetProductBySlugParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Slug     string      `json:"slug"`
}

// Get a single product by slug with all details
func (q *Queries) GetProductBySlug(ctx context.Context, arg GetProductBySlugParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, arg.TenantID, arg.Slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ShortDescription,
		&i.Origin,
		&i.Region,
		&i.Producer,
		&i.Process,
		&i.RoastLevel,
		&i.ElevationMin,
		&i.ElevationMax,
		&i.Variety,
		&i.HarvestYear,
		&i.TastingNotes,
		&i.Status,
		&i.Visibility,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductImages = `-- name: GetProductImages :many
SELECT
    id,
    tenant_id,
    product_id,
    url,
    alt_text,
    width,
    height,
    file_size,
    sort_order,
    is_primary,
    created_at
FROM product_images
WHERE product_id = $1
ORDER BY
    is_primary DESC,
    sort_order ASC,
    created_at ASC
`

// Get all images for a product
func (q *Queries) GetProductImages(ctx context.Context, productID pgtype.UUID) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, getProductImages, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductImage{}
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductID,
			&i.Url,
			&i.AltText,
			&i.Width,
			&i.Height,
			&i.FileSize,
			&i.SortOrder,
			&i.IsPrimary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSKUs = `-- name: GetProductSKUs :many
SELECT
    id,
    tenant_id,
    product_id,
    sku,
    weight_value,
    weight_unit,
    grind,
    base_price_cents,
    inventory_quantity,
    inventory_policy,
    low_stock_threshold,
    is_active,
    weight_grams,
    requires_shipping,
    created_at,
    updated_at
FROM product_skus
WHERE product_id = $1
  AND is_active = TRUE
ORDER BY weight_value ASC, grind ASC
`

// Get all active SKUs for a product
func (q *Queries) GetProductSKUs(ctx context.Context, productID pgtype.UUID) ([]ProductSku, error) {
	rows, err := q.db.Query(ctx, getProductSKUs, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductSku{}
	for rows.Next() {
		var i ProductSku
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductID,
			&i.Sku,
			&i.WeightValue,
			&i.WeightUnit,
			&i.Grind,
			&i.BasePriceCents,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.LowStockThreshold,
			&i.IsActive,
			&i.WeightGrams,
			&i.RequiresShipping,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSKUByID = `-- name: GetSKUByID :one
SELECT
    id,
    tenant_id,
    product_id,
    sku,
    weight_value,
    weight_unit,
    grind,
    base_price_cents,
    inventory_quantity,
    inventory_policy,
    low_stock_threshold,
    is_active,
    weight_grams,
    requires_shipping,
    created_at,
    updated_at
FROM product_skus
WHERE id = $1
  AND is_active = TRUE
LIMIT 1
`

// Get a single SKU by ID
func (q *Queries) GetSKUByID(ctx context.Context, id pgtype.UUID) (ProductSku, error) {
	row := q.db.QueryRow(ctx, getSKUByID, id)
	var i ProductSku
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductID,
		&i.Sku,
		&i.WeightValue,
		&i.WeightUnit,
		&i.Grind,
		&i.BasePriceCents,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.LowStockThreshold,
		&i.IsActive,
		&i.WeightGrams,
		&i.RequiresShipping,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveProducts = `-- name: ListActiveProducts :many
SELECT
    p.id,
    p.tenant_id,
    p.name,
    p.slug,
    p.short_description,
    p.origin,
    p.roast_level,
    p.tasting_notes,
    p.sort_order,
    pi.url as primary_image_url,
    pi.alt_text as primary_image_alt
FROM products p
LEFT JOIN product_images pi ON pi.product_id = p.id AND pi.is_primary = TRUE
WHERE p.tenant_id = $1
  AND p.status = 'active'
  AND p.visibility = 'public'
ORDER BY p.sort_order ASC, p.created_at DESC
`

type ListActiveProductsRow struct {
	ID               pgtype.UUID `json:"id"`
	TenantID         pgtype.UUID `json:"tenant_id"`
	Name             string      `json:"name"`
	Slug             string      `json:"slug"`
	ShortDescription pgtype.Text `json:"short_description"`
	Origin           pgtype.Text `json:"origin"`
	RoastLevel       pgtype.Text `json:"roast_level"`
	TastingNotes     []string    `json:"tasting_notes"`
	SortOrder        int32       `json:"sort_order"`
	PrimaryImageUrl  pgtype.Text `json:"primary_image_url"`
	PrimaryImageAlt  pgtype.Text `json:"primary_image_alt"`
}

// List all active products for a tenant with their primary image
func (q *Queries) ListActiveProducts(ctx context.Context, tenantID pgtype.UUID) ([]ListActiveProductsRow, error) {
	rows, err := q.db.Query(ctx, listActiveProducts, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveProductsRow{}
	for rows.Next() {
		var i ListActiveProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Slug,
			&i.ShortDescription,
			&i.Origin,
			&i.RoastLevel,
			&i.TastingNotes,
			&i.SortOrder,
			&i.PrimaryImageUrl,
			&i.PrimaryImageAlt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
