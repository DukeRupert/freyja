// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operator_sessions.sql

package repository

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveOperatorSessions = `-- name: CountActiveOperatorSessions :one
SELECT COUNT(*)
FROM operator_sessions
WHERE operator_id = $1
  AND expires_at > NOW()
`

// Count active sessions for an operator
func (q *Queries) CountActiveOperatorSessions(ctx context.Context, operatorID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveOperatorSessions, operatorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOperatorSession = `-- name: CreateOperatorSession :one

INSERT INTO operator_sessions (
    operator_id,
    token_hash,
    user_agent,
    ip_address,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, operator_id, token_hash, user_agent, ip_address, expires_at, created_at
`

type CreateOperatorSessionParams struct {
	OperatorID pgtype.UUID        `json:"operator_id"`
	TokenHash  string             `json:"token_hash"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	IpAddress  *netip.Addr        `json:"ip_address"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

// Operator Sessions: Sessions for tenant operators (separate from customer sessions)
// Create a new operator session
func (q *Queries) CreateOperatorSession(ctx context.Context, arg CreateOperatorSessionParams) (OperatorSession, error) {
	row := q.db.QueryRow(ctx, createOperatorSession,
		arg.OperatorID,
		arg.TokenHash,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	var i OperatorSession
	err := row.Scan(
		&i.ID,
		&i.OperatorID,
		&i.TokenHash,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredOperatorSessions = `-- name: DeleteExpiredOperatorSessions :exec
DELETE FROM operator_sessions
WHERE expires_at <= NOW()
`

// Clean up expired operator sessions (background job)
func (q *Queries) DeleteExpiredOperatorSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredOperatorSessions)
	return err
}

const deleteOperatorSession = `-- name: DeleteOperatorSession :exec
DELETE FROM operator_sessions
WHERE token_hash = $1
`

// Delete an operator session (logout)
func (q *Queries) DeleteOperatorSession(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, deleteOperatorSession, tokenHash)
	return err
}

const deleteOperatorSessionByID = `-- name: DeleteOperatorSessionByID :exec
DELETE FROM operator_sessions
WHERE id = $1
`

// Delete an operator session by ID
func (q *Queries) DeleteOperatorSessionByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperatorSessionByID, id)
	return err
}

const deleteOperatorSessionsByOperatorID = `-- name: DeleteOperatorSessionsByOperatorID :exec
DELETE FROM operator_sessions
WHERE operator_id = $1
`

// Delete all sessions for an operator (e.g., password change, force logout)
func (q *Queries) DeleteOperatorSessionsByOperatorID(ctx context.Context, operatorID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperatorSessionsByOperatorID, operatorID)
	return err
}

const getOperatorSessionByTokenHash = `-- name: GetOperatorSessionByTokenHash :one
SELECT id, operator_id, token_hash, user_agent, ip_address, expires_at, created_at
FROM operator_sessions
WHERE token_hash = $1
  AND expires_at > NOW()
LIMIT 1
`

// Get a valid (non-expired) operator session by token hash
func (q *Queries) GetOperatorSessionByTokenHash(ctx context.Context, tokenHash string) (OperatorSession, error) {
	row := q.db.QueryRow(ctx, getOperatorSessionByTokenHash, tokenHash)
	var i OperatorSession
	err := row.Scan(
		&i.ID,
		&i.OperatorID,
		&i.TokenHash,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOperatorSessionsForOperator = `-- name: GetOperatorSessionsForOperator :many
SELECT id, operator_id, token_hash, user_agent, ip_address, expires_at, created_at
FROM operator_sessions
WHERE operator_id = $1
  AND expires_at > NOW()
ORDER BY created_at DESC
`

// Get all active sessions for an operator (for "active sessions" UI)
func (q *Queries) GetOperatorSessionsForOperator(ctx context.Context, operatorID pgtype.UUID) ([]OperatorSession, error) {
	rows, err := q.db.Query(ctx, getOperatorSessionsForOperator, operatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperatorSession{}
	for rows.Next() {
		var i OperatorSession
		if err := rows.Scan(
			&i.ID,
			&i.OperatorID,
			&i.TokenHash,
			&i.UserAgent,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOperatorSessionExpiry = `-- name: UpdateOperatorSessionExpiry :exec
UPDATE operator_sessions
SET expires_at = $2
WHERE id = $1
`

type UpdateOperatorSessionExpiryParams struct {
	ID        pgtype.UUID        `json:"id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// Update session expiry (for sliding window sessions)
func (q *Queries) UpdateOperatorSessionExpiry(ctx context.Context, arg UpdateOperatorSessionExpiryParams) error {
	_, err := q.db.Exec(ctx, updateOperatorSessionExpiry, arg.ID, arg.ExpiresAt)
	return err
}
