// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order_items.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
  order_id, product_id, name, quantity, price, purchase_type, subscription_interval, stripe_price_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, order_id, product_id, name, quantity, price, purchase_type, subscription_interval, stripe_price_id, created_at
`

type CreateOrderItemParams struct {
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
}

type CreateOrderItemRow struct {
	ID                   int32       `db:"id" json:"id"`
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
	CreatedAt            time.Time   `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (CreateOrderItemRow, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Name,
		arg.Quantity,
		arg.Price,
		arg.PurchaseType,
		arg.SubscriptionInterval,
		arg.StripePriceID,
	)
	var i CreateOrderItemRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.PurchaseType,
		&i.SubscriptionInterval,
		&i.StripePriceID,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderItem = `-- name: GetOrderItem :one

SELECT id, order_id, product_id, name, quantity, price, purchase_type, subscription_interval, stripe_price_id, created_at
FROM order_items
WHERE id = $1
`

type GetOrderItemRow struct {
	ID                   int32       `db:"id" json:"id"`
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
	CreatedAt            time.Time   `db:"created_at" json:"created_at"`
}

// internal/database/queries/order_items.sql - Updated queries
func (q *Queries) GetOrderItem(ctx context.Context, id int32) (GetOrderItemRow, error) {
	row := q.db.QueryRow(ctx, getOrderItem, id)
	var i GetOrderItemRow
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Name,
		&i.Quantity,
		&i.Price,
		&i.PurchaseType,
		&i.SubscriptionInterval,
		&i.StripePriceID,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderItemStats = `-- name: GetOrderItemStats :one
SELECT 
  COUNT(*) as total_items,
  COALESCE(SUM(quantity), 0) as total_quantity,
  COALESCE(SUM(quantity * price), 0) as total_value,
  COUNT(CASE WHEN purchase_type = 'one_time' THEN 1 END) as one_time_items,
  COUNT(CASE WHEN purchase_type = 'subscription' THEN 1 END) as subscription_items
FROM order_items
WHERE order_id = $1
`

type GetOrderItemStatsRow struct {
	TotalItems        int64       `db:"total_items" json:"total_items"`
	TotalQuantity     interface{} `db:"total_quantity" json:"total_quantity"`
	TotalValue        interface{} `db:"total_value" json:"total_value"`
	OneTimeItems      int64       `db:"one_time_items" json:"one_time_items"`
	SubscriptionItems int64       `db:"subscription_items" json:"subscription_items"`
}

func (q *Queries) GetOrderItemStats(ctx context.Context, orderID int32) (GetOrderItemStatsRow, error) {
	row := q.db.QueryRow(ctx, getOrderItemStats, orderID)
	var i GetOrderItemStatsRow
	err := row.Scan(
		&i.TotalItems,
		&i.TotalQuantity,
		&i.TotalValue,
		&i.OneTimeItems,
		&i.SubscriptionItems,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT oi.id, oi.order_id, oi.product_id, oi.name, oi.quantity, oi.price, 
       oi.purchase_type, oi.subscription_interval, oi.stripe_price_id, oi.created_at,
       p.stock as product_stock, p.active as product_active
FROM order_items oi
LEFT JOIN products p ON oi.product_id = p.id
WHERE oi.order_id = $1
ORDER BY oi.created_at ASC
`

type GetOrderItemsRow struct {
	ID                   int32       `db:"id" json:"id"`
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
	CreatedAt            time.Time   `db:"created_at" json:"created_at"`
	ProductStock         int32       `db:"product_stock" json:"product_stock"`
	ProductActive        pgtype.Bool `db:"product_active" json:"product_active"`
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID int32) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsRow{}
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.PurchaseType,
			&i.SubscriptionInterval,
			&i.StripePriceID,
			&i.CreatedAt,
			&i.ProductStock,
			&i.ProductActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByProduct = `-- name: GetOrderItemsByProduct :many
SELECT oi.id, oi.order_id, oi.product_id, oi.name, oi.quantity, oi.price, 
       oi.purchase_type, oi.subscription_interval, oi.stripe_price_id, oi.created_at,
       o.customer_id, o.status as order_status
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
WHERE oi.product_id = $1
ORDER BY oi.created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrderItemsByProductParams struct {
	ProductID int32 `db:"product_id" json:"product_id"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

type GetOrderItemsByProductRow struct {
	ID                   int32       `db:"id" json:"id"`
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
	CreatedAt            time.Time   `db:"created_at" json:"created_at"`
	CustomerID           int32       `db:"customer_id" json:"customer_id"`
	OrderStatus          OrderStatus `db:"order_status" json:"order_status"`
}

func (q *Queries) GetOrderItemsByProduct(ctx context.Context, arg GetOrderItemsByProductParams) ([]GetOrderItemsByProductRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByProduct, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsByProductRow{}
	for rows.Next() {
		var i GetOrderItemsByProductRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.PurchaseType,
			&i.SubscriptionInterval,
			&i.StripePriceID,
			&i.CreatedAt,
			&i.CustomerID,
			&i.OrderStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByPurchaseType = `-- name: GetOrderItemsByPurchaseType :many
SELECT id, order_id, product_id, name, quantity, price, purchase_type, subscription_interval, stripe_price_id, created_at
FROM order_items
WHERE order_id = $1 AND purchase_type = $2
ORDER BY created_at ASC
`

type GetOrderItemsByPurchaseTypeParams struct {
	OrderID      int32  `db:"order_id" json:"order_id"`
	PurchaseType string `db:"purchase_type" json:"purchase_type"`
}

type GetOrderItemsByPurchaseTypeRow struct {
	ID                   int32       `db:"id" json:"id"`
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
	CreatedAt            time.Time   `db:"created_at" json:"created_at"`
}

func (q *Queries) GetOrderItemsByPurchaseType(ctx context.Context, arg GetOrderItemsByPurchaseTypeParams) ([]GetOrderItemsByPurchaseTypeRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByPurchaseType, arg.OrderID, arg.PurchaseType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsByPurchaseTypeRow{}
	for rows.Next() {
		var i GetOrderItemsByPurchaseTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.PurchaseType,
			&i.SubscriptionInterval,
			&i.StripePriceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionOrderItems = `-- name: GetSubscriptionOrderItems :many
SELECT id, order_id, product_id, name, quantity, price, purchase_type, subscription_interval, stripe_price_id, created_at
FROM order_items
WHERE order_id = $1 AND purchase_type = 'subscription'
ORDER BY created_at ASC
`

type GetSubscriptionOrderItemsRow struct {
	ID                   int32       `db:"id" json:"id"`
	OrderID              int32       `db:"order_id" json:"order_id"`
	ProductID            int32       `db:"product_id" json:"product_id"`
	Name                 string      `db:"name" json:"name"`
	Quantity             int32       `db:"quantity" json:"quantity"`
	Price                int32       `db:"price" json:"price"`
	PurchaseType         string      `db:"purchase_type" json:"purchase_type"`
	SubscriptionInterval pgtype.Text `db:"subscription_interval" json:"subscription_interval"`
	StripePriceID        string      `db:"stripe_price_id" json:"stripe_price_id"`
	CreatedAt            time.Time   `db:"created_at" json:"created_at"`
}

func (q *Queries) GetSubscriptionOrderItems(ctx context.Context, orderID int32) ([]GetSubscriptionOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscriptionOrderItemsRow{}
	for rows.Next() {
		var i GetSubscriptionOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.PurchaseType,
			&i.SubscriptionInterval,
			&i.StripePriceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
