// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_terms.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsersWithPaymentTerms = `-- name: CountUsersWithPaymentTerms :one
SELECT COUNT(*)
FROM users
WHERE payment_terms_id = $1
`

// Count users using specific payment terms (for safe deletion check)
func (q *Queries) CountUsersWithPaymentTerms(ctx context.Context, paymentTermsID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersWithPaymentTerms, paymentTermsID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPaymentTerms = `-- name: CreatePaymentTerms :one

INSERT INTO payment_terms (
    tenant_id,
    name,
    code,
    days,
    is_default,
    is_active,
    sort_order,
    description
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, tenant_id, name, code, days, is_default, is_active, sort_order, description, created_at, updated_at
`

type CreatePaymentTermsParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Name        string      `json:"name"`
	Code        string      `json:"code"`
	Days        int32       `json:"days"`
	IsDefault   bool        `json:"is_default"`
	IsActive    bool        `json:"is_active"`
	SortOrder   int32       `json:"sort_order"`
	Description pgtype.Text `json:"description"`
}

// Payment Terms Queries
// Manages reusable payment terms for wholesale invoicing
// Create a new payment terms record
func (q *Queries) CreatePaymentTerms(ctx context.Context, arg CreatePaymentTermsParams) (PaymentTerm, error) {
	row := q.db.QueryRow(ctx, createPaymentTerms,
		arg.TenantID,
		arg.Name,
		arg.Code,
		arg.Days,
		arg.IsDefault,
		arg.IsActive,
		arg.SortOrder,
		arg.Description,
	)
	var i PaymentTerm
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.Days,
		&i.IsDefault,
		&i.IsActive,
		&i.SortOrder,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePaymentTerms = `-- name: DeletePaymentTerms :exec
UPDATE payment_terms
SET is_active = FALSE,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type DeletePaymentTermsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Soft delete by deactivating (preserves referential integrity)
func (q *Queries) DeletePaymentTerms(ctx context.Context, arg DeletePaymentTermsParams) error {
	_, err := q.db.Exec(ctx, deletePaymentTerms, arg.TenantID, arg.ID)
	return err
}

const getDefaultPaymentTerms = `-- name: GetDefaultPaymentTerms :one
SELECT id, tenant_id, name, code, days, is_default, is_active, sort_order, description, created_at, updated_at FROM payment_terms
WHERE tenant_id = $1
  AND is_default = TRUE
  AND is_active = TRUE
LIMIT 1
`

// Get the default payment terms for a tenant
func (q *Queries) GetDefaultPaymentTerms(ctx context.Context, tenantID pgtype.UUID) (PaymentTerm, error) {
	row := q.db.QueryRow(ctx, getDefaultPaymentTerms, tenantID)
	var i PaymentTerm
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.Days,
		&i.IsDefault,
		&i.IsActive,
		&i.SortOrder,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentTermsByCode = `-- name: GetPaymentTermsByCode :one
SELECT id, tenant_id, name, code, days, is_default, is_active, sort_order, description, created_at, updated_at FROM payment_terms
WHERE tenant_id = $1
  AND code = $2
  AND is_active = TRUE
LIMIT 1
`

type GetPaymentTermsByCodeParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Code     string      `json:"code"`
}

// Get payment terms by code within a tenant
func (q *Queries) GetPaymentTermsByCode(ctx context.Context, arg GetPaymentTermsByCodeParams) (PaymentTerm, error) {
	row := q.db.QueryRow(ctx, getPaymentTermsByCode, arg.TenantID, arg.Code)
	var i PaymentTerm
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.Days,
		&i.IsDefault,
		&i.IsActive,
		&i.SortOrder,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentTermsByID = `-- name: GetPaymentTermsByID :one
SELECT id, tenant_id, name, code, days, is_default, is_active, sort_order, description, created_at, updated_at FROM payment_terms
WHERE id = $1
  AND tenant_id = $2
LIMIT 1
`

type GetPaymentTermsByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Get payment terms by ID
func (q *Queries) GetPaymentTermsByID(ctx context.Context, arg GetPaymentTermsByIDParams) (PaymentTerm, error) {
	row := q.db.QueryRow(ctx, getPaymentTermsByID, arg.ID, arg.TenantID)
	var i PaymentTerm
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Code,
		&i.Days,
		&i.IsDefault,
		&i.IsActive,
		&i.SortOrder,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllPaymentTerms = `-- name: ListAllPaymentTerms :many
SELECT id, tenant_id, name, code, days, is_default, is_active, sort_order, description, created_at, updated_at FROM payment_terms
WHERE tenant_id = $1
ORDER BY sort_order ASC, name ASC
`

// List all payment terms including inactive (for admin)
func (q *Queries) ListAllPaymentTerms(ctx context.Context, tenantID pgtype.UUID) ([]PaymentTerm, error) {
	rows, err := q.db.Query(ctx, listAllPaymentTerms, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentTerm{}
	for rows.Next() {
		var i PaymentTerm
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Code,
			&i.Days,
			&i.IsDefault,
			&i.IsActive,
			&i.SortOrder,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentTerms = `-- name: ListPaymentTerms :many
SELECT id, tenant_id, name, code, days, is_default, is_active, sort_order, description, created_at, updated_at FROM payment_terms
WHERE tenant_id = $1
  AND is_active = TRUE
ORDER BY sort_order ASC, name ASC
`

// List all payment terms for a tenant
func (q *Queries) ListPaymentTerms(ctx context.Context, tenantID pgtype.UUID) ([]PaymentTerm, error) {
	rows, err := q.db.Query(ctx, listPaymentTerms, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentTerm{}
	for rows.Next() {
		var i PaymentTerm
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Code,
			&i.Days,
			&i.IsDefault,
			&i.IsActive,
			&i.SortOrder,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultPaymentTerms = `-- name: SetDefaultPaymentTerms :exec
UPDATE payment_terms
SET is_default = (id = $2)
WHERE tenant_id = $1
`

type SetDefaultPaymentTermsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Set payment terms as default (clears previous default)
func (q *Queries) SetDefaultPaymentTerms(ctx context.Context, arg SetDefaultPaymentTermsParams) error {
	_, err := q.db.Exec(ctx, setDefaultPaymentTerms, arg.TenantID, arg.ID)
	return err
}

const updatePaymentTerms = `-- name: UpdatePaymentTerms :exec
UPDATE payment_terms
SET
    name = $3,
    code = $4,
    days = $5,
    is_default = $6,
    is_active = $7,
    sort_order = $8,
    description = $9,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdatePaymentTermsParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Code        string      `json:"code"`
	Days        int32       `json:"days"`
	IsDefault   bool        `json:"is_default"`
	IsActive    bool        `json:"is_active"`
	SortOrder   int32       `json:"sort_order"`
	Description pgtype.Text `json:"description"`
}

// Update payment terms
func (q *Queries) UpdatePaymentTerms(ctx context.Context, arg UpdatePaymentTermsParams) error {
	_, err := q.db.Exec(ctx, updatePaymentTerms,
		arg.TenantID,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.Days,
		arg.IsDefault,
		arg.IsActive,
		arg.SortOrder,
		arg.Description,
	)
	return err
}
