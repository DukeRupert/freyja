// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenant_operators.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateOperator = `-- name: ActivateOperator :exec
UPDATE tenant_operators
SET
    status = 'active',
    updated_at = NOW()
WHERE id = $1
  AND tenant_id = $2
`

type ActivateOperatorParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Activate a suspended operator account
func (q *Queries) ActivateOperator(ctx context.Context, arg ActivateOperatorParams) error {
	_, err := q.db.Exec(ctx, activateOperator, arg.ID, arg.TenantID)
	return err
}

const clearOperatorSetupToken = `-- name: ClearOperatorSetupToken :exec
UPDATE tenant_operators
SET
    setup_token_hash = NULL,
    setup_token_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Clear setup token after successful use
func (q *Queries) ClearOperatorSetupToken(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearOperatorSetupToken, id)
	return err
}

const countOperatorsByTenant = `-- name: CountOperatorsByTenant :one
SELECT COUNT(*)
FROM tenant_operators
WHERE tenant_id = $1
`

// Count operators for a tenant
func (q *Queries) CountOperatorsByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOperatorsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTenantOperator = `-- name: CreateTenantOperator :one

INSERT INTO tenant_operators (
    tenant_id,
    email,
    name,
    role,
    setup_token_hash,
    setup_token_expires_at,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, 'pending'
) RETURNING id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
`

type CreateTenantOperatorParams struct {
	TenantID            pgtype.UUID        `json:"tenant_id"`
	Email               string             `json:"email"`
	Name                pgtype.Text        `json:"name"`
	Role                string             `json:"role"`
	SetupTokenHash      pgtype.Text        `json:"setup_token_hash"`
	SetupTokenExpiresAt pgtype.Timestamptz `json:"setup_token_expires_at"`
}

// Tenant Operators: People who manage a tenant (roaster staff who pay for Freyja)
// Separate from users table (storefront customers)
// Create a new tenant operator (called after Stripe checkout)
func (q *Queries) CreateTenantOperator(ctx context.Context, arg CreateTenantOperatorParams) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, createTenantOperator,
		arg.TenantID,
		arg.Email,
		arg.Name,
		arg.Role,
		arg.SetupTokenHash,
		arg.SetupTokenExpiresAt,
	)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTenantOperator = `-- name: DeleteTenantOperator :exec
DELETE FROM tenant_operators
WHERE id = $1
  AND tenant_id = $2
`

type DeleteTenantOperatorParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Delete an operator (for cleanup/testing)
func (q *Queries) DeleteTenantOperator(ctx context.Context, arg DeleteTenantOperatorParams) error {
	_, err := q.db.Exec(ctx, deleteTenantOperator, arg.ID, arg.TenantID)
	return err
}

const getTenantOperatorByEmail = `-- name: GetTenantOperatorByEmail :one
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE email = $1
LIMIT 1
`

// Get operator by email (global lookup for login)
func (q *Queries) GetTenantOperatorByEmail(ctx context.Context, email string) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, getTenantOperatorByEmail, email)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantOperatorByEmailAndTenant = `-- name: GetTenantOperatorByEmailAndTenant :one
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE tenant_id = $1
  AND email = $2
LIMIT 1
`

type GetTenantOperatorByEmailAndTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Email    string      `json:"email"`
}

// Get operator by email within a specific tenant
func (q *Queries) GetTenantOperatorByEmailAndTenant(ctx context.Context, arg GetTenantOperatorByEmailAndTenantParams) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, getTenantOperatorByEmailAndTenant, arg.TenantID, arg.Email)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantOperatorByID = `-- name: GetTenantOperatorByID :one
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE id = $1
LIMIT 1
`

// Get operator by ID
func (q *Queries) GetTenantOperatorByID(ctx context.Context, id pgtype.UUID) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, getTenantOperatorByID, id)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantOperatorByIDAndTenant = `-- name: GetTenantOperatorByIDAndTenant :one
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE id = $1
  AND tenant_id = $2
LIMIT 1
`

type GetTenantOperatorByIDAndTenantParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Get operator by ID within a specific tenant (for session validation)
func (q *Queries) GetTenantOperatorByIDAndTenant(ctx context.Context, arg GetTenantOperatorByIDAndTenantParams) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, getTenantOperatorByIDAndTenant, arg.ID, arg.TenantID)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantOperatorByResetToken = `-- name: GetTenantOperatorByResetToken :one
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE reset_token_hash = $1
  AND reset_token_expires_at > NOW()
LIMIT 1
`

// Get operator by valid (non-expired) reset token
func (q *Queries) GetTenantOperatorByResetToken(ctx context.Context, resetTokenHash pgtype.Text) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, getTenantOperatorByResetToken, resetTokenHash)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantOperatorBySetupToken = `-- name: GetTenantOperatorBySetupToken :one
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE setup_token_hash = $1
  AND setup_token_expires_at > NOW()
  AND status = 'pending'
LIMIT 1
`

// Get operator by valid (non-expired) setup token
func (q *Queries) GetTenantOperatorBySetupToken(ctx context.Context, setupTokenHash pgtype.Text) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, getTenantOperatorBySetupToken, setupTokenHash)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTenantOperators = `-- name: ListTenantOperators :many
SELECT id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
FROM tenant_operators
WHERE tenant_id = $1
ORDER BY created_at ASC
`

// List all operators for a tenant (for future multi-user support)
func (q *Queries) ListTenantOperators(ctx context.Context, tenantID pgtype.UUID) ([]TenantOperator, error) {
	rows, err := q.db.Query(ctx, listTenantOperators, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TenantOperator{}
	for rows.Next() {
		var i TenantOperator
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.PasswordHash,
			&i.Name,
			&i.Role,
			&i.SetupTokenHash,
			&i.SetupTokenExpiresAt,
			&i.ResetTokenHash,
			&i.ResetTokenExpiresAt,
			&i.Status,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setOperatorPassword = `-- name: SetOperatorPassword :exec
UPDATE tenant_operators
SET
    password_hash = $2,
    status = 'active',
    setup_token_hash = NULL,
    setup_token_expires_at = NULL,
    reset_token_hash = NULL,
    reset_token_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

type SetOperatorPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

// Set operator password and activate account (called during setup)
func (q *Queries) SetOperatorPassword(ctx context.Context, arg SetOperatorPasswordParams) error {
	_, err := q.db.Exec(ctx, setOperatorPassword, arg.ID, arg.PasswordHash)
	return err
}

const setOperatorResetToken = `-- name: SetOperatorResetToken :exec
UPDATE tenant_operators
SET
    reset_token_hash = $2,
    reset_token_expires_at = $3,
    updated_at = NOW()
WHERE id = $1
`

type SetOperatorResetTokenParams struct {
	ID                  pgtype.UUID        `json:"id"`
	ResetTokenHash      pgtype.Text        `json:"reset_token_hash"`
	ResetTokenExpiresAt pgtype.Timestamptz `json:"reset_token_expires_at"`
}

// Set password reset token for an operator
func (q *Queries) SetOperatorResetToken(ctx context.Context, arg SetOperatorResetTokenParams) error {
	_, err := q.db.Exec(ctx, setOperatorResetToken, arg.ID, arg.ResetTokenHash, arg.ResetTokenExpiresAt)
	return err
}

const setOperatorSetupToken = `-- name: SetOperatorSetupToken :exec
UPDATE tenant_operators
SET
    setup_token_hash = $2,
    setup_token_expires_at = $3,
    updated_at = NOW()
WHERE id = $1
`

type SetOperatorSetupTokenParams struct {
	ID                  pgtype.UUID        `json:"id"`
	SetupTokenHash      pgtype.Text        `json:"setup_token_hash"`
	SetupTokenExpiresAt pgtype.Timestamptz `json:"setup_token_expires_at"`
}

// Set or refresh setup token for an operator
func (q *Queries) SetOperatorSetupToken(ctx context.Context, arg SetOperatorSetupTokenParams) error {
	_, err := q.db.Exec(ctx, setOperatorSetupToken, arg.ID, arg.SetupTokenHash, arg.SetupTokenExpiresAt)
	return err
}

const suspendOperator = `-- name: SuspendOperator :exec
UPDATE tenant_operators
SET
    status = 'suspended',
    updated_at = NOW()
WHERE id = $1
  AND tenant_id = $2
`

type SuspendOperatorParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Suspend an operator account
func (q *Queries) SuspendOperator(ctx context.Context, arg SuspendOperatorParams) error {
	_, err := q.db.Exec(ctx, suspendOperator, arg.ID, arg.TenantID)
	return err
}

const updateOperatorLastLogin = `-- name: UpdateOperatorLastLogin :exec
UPDATE tenant_operators
SET
    last_login_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

// Update last login timestamp
func (q *Queries) UpdateOperatorLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateOperatorLastLogin, id)
	return err
}

const updateOperatorPassword = `-- name: UpdateOperatorPassword :exec
UPDATE tenant_operators
SET
    password_hash = $2,
    reset_token_hash = NULL,
    reset_token_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

type UpdateOperatorPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

// Update operator password (for password resets)
func (q *Queries) UpdateOperatorPassword(ctx context.Context, arg UpdateOperatorPasswordParams) error {
	_, err := q.db.Exec(ctx, updateOperatorPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateOperatorProfile = `-- name: UpdateOperatorProfile :one
UPDATE tenant_operators
SET
    name = COALESCE($3, name),
    email = COALESCE($4, email),
    updated_at = NOW()
WHERE id = $1
  AND tenant_id = $2
RETURNING id, tenant_id, email, password_hash, name, role, setup_token_hash, setup_token_expires_at, reset_token_hash, reset_token_expires_at, status, last_login_at, created_at, updated_at
`

type UpdateOperatorProfileParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Name     pgtype.Text `json:"name"`
	Email    pgtype.Text `json:"email"`
}

// Update operator profile information
func (q *Queries) UpdateOperatorProfile(ctx context.Context, arg UpdateOperatorProfileParams) (TenantOperator, error) {
	row := q.db.QueryRow(ctx, updateOperatorProfile,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Email,
	)
	var i TenantOperator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.Role,
		&i.SetupTokenHash,
		&i.SetupTokenExpiresAt,
		&i.ResetTokenHash,
		&i.ResetTokenExpiresAt,
		&i.Status,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
