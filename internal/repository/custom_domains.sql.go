// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: custom_domains.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateCustomDomain = `-- name: ActivateCustomDomain :exec
UPDATE tenants
SET custom_domain_status = 'active',
    custom_domain_activated_at = NOW(),
    custom_domain_last_checked_at = NOW(),
    updated_at = NOW()
WHERE id = $1
  AND custom_domain_status = 'verified'
`

// Activate a verified custom domain
// Domain must be in 'verified' status
// After this, Caddy will provision TLS certificate and serve traffic
func (q *Queries) ActivateCustomDomain(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, activateCustomDomain, id)
	return err
}

const cleanupStalePendingDomains = `-- name: CleanupStalePendingDomains :exec

DELETE FROM tenants
WHERE custom_domain_status = 'pending'
  AND updated_at < NOW() - INTERVAL '30 days'
`

// ============================================================================
// BACKGROUND JOBS - CLEANUP
// ============================================================================
// Remove domains stuck in 'pending' status for > 30 days
// Used by weekly cleanup job to free up abandoned domain claims
func (q *Queries) CleanupStalePendingDomains(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupStalePendingDomains)
	return err
}

const deactivateCustomDomain = `-- name: DeactivateCustomDomain :exec
UPDATE tenants
SET custom_domain = NULL,
    custom_domain_status = 'none',
    custom_domain_verification_token = NULL,
    custom_domain_verified_at = NULL,
    custom_domain_activated_at = NULL,
    custom_domain_last_checked_at = NULL,
    custom_domain_error_message = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Deactivate a custom domain (set back to 'none')
// Removes all custom domain data
// Used when tenant removes their custom domain
func (q *Queries) DeactivateCustomDomain(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateCustomDomain, id)
	return err
}

const getActiveCustomDomains = `-- name: GetActiveCustomDomains :many

SELECT
    id,
    custom_domain,
    custom_domain_last_checked_at
FROM tenants
WHERE custom_domain_status = 'active'
  AND custom_domain IS NOT NULL
ORDER BY custom_domain_last_checked_at ASC NULLS FIRST
`

type GetActiveCustomDomainsRow struct {
	ID                        pgtype.UUID        `json:"id"`
	CustomDomain              pgtype.Text        `json:"custom_domain"`
	CustomDomainLastCheckedAt pgtype.Timestamptz `json:"custom_domain_last_checked_at"`
}

// ============================================================================
// BACKGROUND JOBS - HEALTH MONITORING
// ============================================================================
// Get all tenants with active custom domains for health monitoring
// Used by daily background job to verify CNAME records are still valid
func (q *Queries) GetActiveCustomDomains(ctx context.Context) ([]GetActiveCustomDomainsRow, error) {
	rows, err := q.db.Query(ctx, getActiveCustomDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveCustomDomainsRow{}
	for rows.Next() {
		var i GetActiveCustomDomainsRow
		if err := rows.Scan(&i.ID, &i.CustomDomain, &i.CustomDomainLastCheckedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomDomainCount = `-- name: GetCustomDomainCount :one
SELECT
    COUNT(*) FILTER (WHERE custom_domain_status = 'active') as active_count,
    COUNT(*) FILTER (WHERE custom_domain_status = 'verified') as verified_count,
    COUNT(*) FILTER (WHERE custom_domain_status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE custom_domain_status = 'failed') as failed_count
FROM tenants
WHERE custom_domain IS NOT NULL
`

type GetCustomDomainCountRow struct {
	ActiveCount   int64 `json:"active_count"`
	VerifiedCount int64 `json:"verified_count"`
	PendingCount  int64 `json:"pending_count"`
	FailedCount   int64 `json:"failed_count"`
}

// Get count of custom domains by status
// Used for admin dashboard metrics
func (q *Queries) GetCustomDomainCount(ctx context.Context) (GetCustomDomainCountRow, error) {
	row := q.db.QueryRow(ctx, getCustomDomainCount)
	var i GetCustomDomainCountRow
	err := row.Scan(
		&i.ActiveCount,
		&i.VerifiedCount,
		&i.PendingCount,
		&i.FailedCount,
	)
	return i, err
}

const getCustomDomainStatus = `-- name: GetCustomDomainStatus :one
SELECT
    custom_domain,
    custom_domain_status,
    custom_domain_verification_token,
    custom_domain_verified_at,
    custom_domain_activated_at,
    custom_domain_last_checked_at,
    custom_domain_error_message
FROM tenants
WHERE id = $1
`

type GetCustomDomainStatusRow struct {
	CustomDomain                  pgtype.Text        `json:"custom_domain"`
	CustomDomainStatus            string             `json:"custom_domain_status"`
	CustomDomainVerificationToken pgtype.Text        `json:"custom_domain_verification_token"`
	CustomDomainVerifiedAt        pgtype.Timestamptz `json:"custom_domain_verified_at"`
	CustomDomainActivatedAt       pgtype.Timestamptz `json:"custom_domain_activated_at"`
	CustomDomainLastCheckedAt     pgtype.Timestamptz `json:"custom_domain_last_checked_at"`
	CustomDomainErrorMessage      pgtype.Text        `json:"custom_domain_error_message"`
}

// Get current custom domain status for a tenant
// Returns all custom domain fields for display in admin UI
func (q *Queries) GetCustomDomainStatus(ctx context.Context, id pgtype.UUID) (GetCustomDomainStatusRow, error) {
	row := q.db.QueryRow(ctx, getCustomDomainStatus, id)
	var i GetCustomDomainStatusRow
	err := row.Scan(
		&i.CustomDomain,
		&i.CustomDomainStatus,
		&i.CustomDomainVerificationToken,
		&i.CustomDomainVerifiedAt,
		&i.CustomDomainActivatedAt,
		&i.CustomDomainLastCheckedAt,
		&i.CustomDomainErrorMessage,
	)
	return i, err
}

const getCustomDomainsByStatus = `-- name: GetCustomDomainsByStatus :many

SELECT
    t.id,
    t.slug,
    t.name,
    t.custom_domain,
    t.custom_domain_status,
    t.custom_domain_verified_at,
    t.custom_domain_activated_at,
    t.custom_domain_last_checked_at,
    t.custom_domain_error_message
FROM tenants t
WHERE t.custom_domain_status = $1
  AND t.custom_domain IS NOT NULL
ORDER BY t.updated_at DESC
`

type GetCustomDomainsByStatusRow struct {
	ID                        pgtype.UUID        `json:"id"`
	Slug                      string             `json:"slug"`
	Name                      string             `json:"name"`
	CustomDomain              pgtype.Text        `json:"custom_domain"`
	CustomDomainStatus        string             `json:"custom_domain_status"`
	CustomDomainVerifiedAt    pgtype.Timestamptz `json:"custom_domain_verified_at"`
	CustomDomainActivatedAt   pgtype.Timestamptz `json:"custom_domain_activated_at"`
	CustomDomainLastCheckedAt pgtype.Timestamptz `json:"custom_domain_last_checked_at"`
	CustomDomainErrorMessage  pgtype.Text        `json:"custom_domain_error_message"`
}

// ============================================================================
// ADMIN QUERIES
// ============================================================================
// Get all custom domains filtered by status
// Used for admin reporting and monitoring
func (q *Queries) GetCustomDomainsByStatus(ctx context.Context, customDomainStatus string) ([]GetCustomDomainsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getCustomDomainsByStatus, customDomainStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomDomainsByStatusRow{}
	for rows.Next() {
		var i GetCustomDomainsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.CustomDomain,
			&i.CustomDomainStatus,
			&i.CustomDomainVerifiedAt,
			&i.CustomDomainActivatedAt,
			&i.CustomDomainLastCheckedAt,
			&i.CustomDomainErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantByCustomDomain = `-- name: GetTenantByCustomDomain :one


SELECT id, slug, name, custom_domain, custom_domain_status, status
FROM tenants
WHERE custom_domain = $1
  AND custom_domain_status = 'active'
LIMIT 1
`

type GetTenantByCustomDomainRow struct {
	ID                 pgtype.UUID `json:"id"`
	Slug               string      `json:"slug"`
	Name               string      `json:"name"`
	CustomDomain       pgtype.Text `json:"custom_domain"`
	CustomDomainStatus string      `json:"custom_domain_status"`
	Status             string      `json:"status"`
}

// ============================================================================
// CUSTOM DOMAIN QUERIES
// ============================================================================
// These queries manage tenant custom domains including:
// - DNS verification workflow
// - Domain activation and deactivation
// - Health monitoring
// ============================================================================
// ============================================================================
// TENANT RESOLUTION
// ============================================================================
// Lookup tenant by custom domain (used in tenant resolution middleware)
// CRITICAL PATH: This query runs on every request to a custom domain
// Returns tenant only if domain status is 'active'
func (q *Queries) GetTenantByCustomDomain(ctx context.Context, customDomain pgtype.Text) (GetTenantByCustomDomainRow, error) {
	row := q.db.QueryRow(ctx, getTenantByCustomDomain, customDomain)
	var i GetTenantByCustomDomainRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.CustomDomain,
		&i.CustomDomainStatus,
		&i.Status,
	)
	return i, err
}

const markDomainVerificationFailed = `-- name: MarkDomainVerificationFailed :exec
UPDATE tenants
SET custom_domain_status = 'failed',
    custom_domain_error_message = $2,
    updated_at = NOW()
WHERE id = $1
  AND custom_domain_status = 'verifying'
`

type MarkDomainVerificationFailedParams struct {
	ID                       pgtype.UUID `json:"id"`
	CustomDomainErrorMessage pgtype.Text `json:"custom_domain_error_message"`
}

// Mark domain verification as failed with error message
// Parameters:
//
//	$1: tenant_id (UUID)
//	$2: error_message (TEXT)
func (q *Queries) MarkDomainVerificationFailed(ctx context.Context, arg MarkDomainVerificationFailedParams) error {
	_, err := q.db.Exec(ctx, markDomainVerificationFailed, arg.ID, arg.CustomDomainErrorMessage)
	return err
}

const markDomainVerified = `-- name: MarkDomainVerified :exec
UPDATE tenants
SET custom_domain_status = 'verified',
    custom_domain_verified_at = NOW(),
    custom_domain_error_message = NULL,
    updated_at = NOW()
WHERE id = $1
  AND custom_domain_status = 'verifying'
`

// Mark domain as 'verified' after successful DNS verification
// Domain can now be activated by tenant
func (q *Queries) MarkDomainVerified(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markDomainVerified, id)
	return err
}

const markDomainVerifying = `-- name: MarkDomainVerifying :exec
UPDATE tenants
SET custom_domain_status = 'verifying',
    custom_domain_error_message = NULL,
    updated_at = NOW()
WHERE id = $1
  AND custom_domain_status IN ('pending', 'failed')
`

// Mark domain as 'verifying' during DNS check
// Used to prevent concurrent verification attempts
func (q *Queries) MarkDomainVerifying(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markDomainVerifying, id)
	return err
}

const setCustomDomain = `-- name: SetCustomDomain :exec

UPDATE tenants
SET custom_domain = $2,
    custom_domain_status = 'pending',
    custom_domain_verification_token = $3,
    custom_domain_verified_at = NULL,
    custom_domain_activated_at = NULL,
    custom_domain_last_checked_at = NULL,
    custom_domain_error_message = NULL,
    updated_at = NOW()
WHERE id = $1
`

type SetCustomDomainParams struct {
	ID                            pgtype.UUID `json:"id"`
	CustomDomain                  pgtype.Text `json:"custom_domain"`
	CustomDomainVerificationToken pgtype.Text `json:"custom_domain_verification_token"`
}

// ============================================================================
// CUSTOM DOMAIN MANAGEMENT
// ============================================================================
// Initiate custom domain setup
// Sets domain to 'pending' status and stores verification token hash
// Parameters:
//
//	$1: tenant_id (UUID)
//	$2: custom_domain (VARCHAR) - e.g., "shop.example.com"
//	$3: verification_token_hash (VARCHAR) - SHA-256 hash of verification token
func (q *Queries) SetCustomDomain(ctx context.Context, arg SetCustomDomainParams) error {
	_, err := q.db.Exec(ctx, setCustomDomain, arg.ID, arg.CustomDomain, arg.CustomDomainVerificationToken)
	return err
}

const updateCustomDomainHealthCheck = `-- name: UpdateCustomDomainHealthCheck :exec
UPDATE tenants
SET custom_domain_last_checked_at = NOW(),
    custom_domain_status = CASE
        WHEN $2 = true THEN 'active'
        ELSE 'failed'
    END,
    custom_domain_error_message = CASE
        WHEN $2 = true THEN NULL
        ELSE $3
    END,
    updated_at = NOW()
WHERE id = $1
  AND custom_domain_status = 'active'
`

type UpdateCustomDomainHealthCheckParams struct {
	ID                       pgtype.UUID `json:"id"`
	Column2                  interface{} `json:"column_2"`
	CustomDomainErrorMessage pgtype.Text `json:"custom_domain_error_message"`
}

// Update last_checked_at timestamp after health check
// Parameters:
//
//	$1: tenant_id (UUID)
//	$2: is_healthy (BOOLEAN) - true if CNAME still valid
//	$3: error_message (TEXT) - NULL if healthy, error message if unhealthy
func (q *Queries) UpdateCustomDomainHealthCheck(ctx context.Context, arg UpdateCustomDomainHealthCheckParams) error {
	_, err := q.db.Exec(ctx, updateCustomDomainHealthCheck, arg.ID, arg.Column2, arg.CustomDomainErrorMessage)
	return err
}

const validateDomainForCaddy = `-- name: ValidateDomainForCaddy :one

SELECT EXISTS(
    SELECT 1 FROM tenants
    WHERE custom_domain = $1
      AND custom_domain_status = 'active'
) as is_valid
`

// ============================================================================
// CADDY VALIDATION
// ============================================================================
// Validate domain for Caddy's on-demand TLS 'ask' endpoint
// Returns true if domain is valid and active, false otherwise
// Caddy calls this before issuing a Let's Encrypt certificate
func (q *Queries) ValidateDomainForCaddy(ctx context.Context, customDomain pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, validateDomainForCaddy, customDomain)
	var is_valid bool
	err := row.Scan(&is_valid)
	return is_valid, err
}
