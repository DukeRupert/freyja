// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoices.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInvoices = `-- name: CountInvoices :one
SELECT COUNT(*)
FROM invoices
WHERE tenant_id = $1
`

// Count invoices for pagination
func (q *Queries) CountInvoices(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoices, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvoice = `-- name: CreateInvoice :one


INSERT INTO invoices (
    tenant_id,
    user_id,
    invoice_number,
    status,
    subtotal_cents,
    tax_cents,
    shipping_cents,
    discount_cents,
    total_cents,
    paid_cents,
    balance_cents,
    currency,
    payment_terms,
    payment_terms_id,
    due_date,
    billing_customer_id,
    billing_address_id,
    customer_notes,
    internal_notes,
    billing_period_start,
    billing_period_end,
    is_proforma
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
    $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
)
RETURNING id, tenant_id, user_id, invoice_number, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, paid_cents, balance_cents, currency, payment_terms, due_date, billing_customer_id, provider, provider_invoice_id, billing_address_id, customer_notes, internal_notes, metadata, sent_at, viewed_at, paid_at, voided_at, created_at, updated_at, payment_terms_id, billing_period_start, billing_period_end, is_proforma
`

type CreateInvoiceParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	UserID             pgtype.UUID `json:"user_id"`
	InvoiceNumber      string      `json:"invoice_number"`
	Status             string      `json:"status"`
	SubtotalCents      int32       `json:"subtotal_cents"`
	TaxCents           int32       `json:"tax_cents"`
	ShippingCents      int32       `json:"shipping_cents"`
	DiscountCents      int32       `json:"discount_cents"`
	TotalCents         int32       `json:"total_cents"`
	PaidCents          int32       `json:"paid_cents"`
	BalanceCents       int32       `json:"balance_cents"`
	Currency           string      `json:"currency"`
	PaymentTerms       string      `json:"payment_terms"`
	PaymentTermsID     pgtype.UUID `json:"payment_terms_id"`
	DueDate            pgtype.Date `json:"due_date"`
	BillingCustomerID  pgtype.UUID `json:"billing_customer_id"`
	BillingAddressID   pgtype.UUID `json:"billing_address_id"`
	CustomerNotes      pgtype.Text `json:"customer_notes"`
	InternalNotes      pgtype.Text `json:"internal_notes"`
	BillingPeriodStart pgtype.Date `json:"billing_period_start"`
	BillingPeriodEnd   pgtype.Date `json:"billing_period_end"`
	IsProforma         bool        `json:"is_proforma"`
}

// Invoice Queries
// Manages wholesale billing invoices
// =============================================================================
// INVOICE CRUD
// =============================================================================
// Create a new invoice
func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.TenantID,
		arg.UserID,
		arg.InvoiceNumber,
		arg.Status,
		arg.SubtotalCents,
		arg.TaxCents,
		arg.ShippingCents,
		arg.DiscountCents,
		arg.TotalCents,
		arg.PaidCents,
		arg.BalanceCents,
		arg.Currency,
		arg.PaymentTerms,
		arg.PaymentTermsID,
		arg.DueDate,
		arg.BillingCustomerID,
		arg.BillingAddressID,
		arg.CustomerNotes,
		arg.InternalNotes,
		arg.BillingPeriodStart,
		arg.BillingPeriodEnd,
		arg.IsProforma,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.InvoiceNumber,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.PaidCents,
		&i.BalanceCents,
		&i.Currency,
		&i.PaymentTerms,
		&i.DueDate,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderInvoiceID,
		&i.BillingAddressID,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.Metadata,
		&i.SentAt,
		&i.ViewedAt,
		&i.PaidAt,
		&i.VoidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentTermsID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.IsProforma,
	)
	return i, err
}

const createInvoiceItem = `-- name: CreateInvoiceItem :one

INSERT INTO invoice_items (
    tenant_id,
    invoice_id,
    item_type,
    product_sku_id,
    order_id,
    description,
    quantity,
    unit_price_cents,
    total_price_cents
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, invoice_id, item_type, product_sku_id, order_id, description, quantity, unit_price_cents, total_price_cents, metadata, created_at, updated_at
`

type CreateInvoiceItemParams struct {
	TenantID        pgtype.UUID    `json:"tenant_id"`
	InvoiceID       pgtype.UUID    `json:"invoice_id"`
	ItemType        string         `json:"item_type"`
	ProductSkuID    pgtype.UUID    `json:"product_sku_id"`
	OrderID         pgtype.UUID    `json:"order_id"`
	Description     string         `json:"description"`
	Quantity        pgtype.Numeric `json:"quantity"`
	UnitPriceCents  int32          `json:"unit_price_cents"`
	TotalPriceCents int32          `json:"total_price_cents"`
}

// =============================================================================
// INVOICE ITEMS
// =============================================================================
// Create an invoice line item
func (q *Queries) CreateInvoiceItem(ctx context.Context, arg CreateInvoiceItemParams) (InvoiceItem, error) {
	row := q.db.QueryRow(ctx, createInvoiceItem,
		arg.TenantID,
		arg.InvoiceID,
		arg.ItemType,
		arg.ProductSkuID,
		arg.OrderID,
		arg.Description,
		arg.Quantity,
		arg.UnitPriceCents,
		arg.TotalPriceCents,
	)
	var i InvoiceItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.InvoiceID,
		&i.ItemType,
		&i.ProductSkuID,
		&i.OrderID,
		&i.Description,
		&i.Quantity,
		&i.UnitPriceCents,
		&i.TotalPriceCents,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvoiceOrder = `-- name: CreateInvoiceOrder :one

INSERT INTO invoice_orders (
    tenant_id,
    invoice_id,
    order_id,
    order_number,
    order_total_cents
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, invoice_id, order_id, order_number, order_total_cents, created_at
`

type CreateInvoiceOrderParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	InvoiceID       pgtype.UUID `json:"invoice_id"`
	OrderID         pgtype.UUID `json:"order_id"`
	OrderNumber     string      `json:"order_number"`
	OrderTotalCents int32       `json:"order_total_cents"`
}

// =============================================================================
// INVOICE-ORDER LINKING (Consolidated Invoicing)
// =============================================================================
// Link an order to an invoice
func (q *Queries) CreateInvoiceOrder(ctx context.Context, arg CreateInvoiceOrderParams) (InvoiceOrder, error) {
	row := q.db.QueryRow(ctx, createInvoiceOrder,
		arg.TenantID,
		arg.InvoiceID,
		arg.OrderID,
		arg.OrderNumber,
		arg.OrderTotalCents,
	)
	var i InvoiceOrder
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.InvoiceID,
		&i.OrderID,
		&i.OrderNumber,
		&i.OrderTotalCents,
		&i.CreatedAt,
	)
	return i, err
}

const createInvoicePayment = `-- name: CreateInvoicePayment :one

INSERT INTO invoice_payments (
    tenant_id,
    invoice_id,
    payment_id,
    amount_cents,
    payment_method,
    payment_reference,
    notes,
    payment_date
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, tenant_id, invoice_id, payment_id, amount_cents, payment_method, payment_reference, notes, metadata, payment_date, created_at, updated_at
`

type CreateInvoicePaymentParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	InvoiceID        pgtype.UUID `json:"invoice_id"`
	PaymentID        pgtype.UUID `json:"payment_id"`
	AmountCents      int32       `json:"amount_cents"`
	PaymentMethod    pgtype.Text `json:"payment_method"`
	PaymentReference pgtype.Text `json:"payment_reference"`
	Notes            pgtype.Text `json:"notes"`
	PaymentDate      pgtype.Date `json:"payment_date"`
}

// =============================================================================
// INVOICE PAYMENTS
// =============================================================================
// Record a payment against an invoice
// Note: The update_invoice_balance trigger automatically updates invoice totals
func (q *Queries) CreateInvoicePayment(ctx context.Context, arg CreateInvoicePaymentParams) (InvoicePayment, error) {
	row := q.db.QueryRow(ctx, createInvoicePayment,
		arg.TenantID,
		arg.InvoiceID,
		arg.PaymentID,
		arg.AmountCents,
		arg.PaymentMethod,
		arg.PaymentReference,
		arg.Notes,
		arg.PaymentDate,
	)
	var i InvoicePayment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.InvoiceID,
		&i.PaymentID,
		&i.AmountCents,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.Notes,
		&i.Metadata,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const generateInvoiceNumber = `-- name: GenerateInvoiceNumber :one
SELECT 'INV-' || TO_CHAR(NOW(), 'YYYYMM') || '-' ||
       LPAD((COALESCE(MAX(
           CASE WHEN invoice_number LIKE 'INV-' || TO_CHAR(NOW(), 'YYYYMM') || '-%'
                THEN CAST(SUBSTRING(invoice_number FROM 13) AS INTEGER)
                ELSE 0
           END
       ), 0) + 1)::TEXT, 4, '0') as next_invoice_number
FROM invoices
WHERE tenant_id = $1
`

// Generate next invoice number for a tenant
// Format: INV-YYYYMM-XXXX (e.g., INV-202412-0001)
func (q *Queries) GenerateInvoiceNumber(ctx context.Context, tenantID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, generateInvoiceNumber, tenantID)
	var next_invoice_number interface{}
	err := row.Scan(&next_invoice_number)
	return next_invoice_number, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, tenant_id, user_id, invoice_number, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, paid_cents, balance_cents, currency, payment_terms, due_date, billing_customer_id, provider, provider_invoice_id, billing_address_id, customer_notes, internal_notes, metadata, sent_at, viewed_at, paid_at, voided_at, created_at, updated_at, payment_terms_id, billing_period_start, billing_period_end, is_proforma FROM invoices
WHERE id = $1
  AND tenant_id = $2
LIMIT 1
`

type GetInvoiceByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

// Get invoice by ID
func (q *Queries) GetInvoiceByID(ctx context.Context, arg GetInvoiceByIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, arg.ID, arg.TenantID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.InvoiceNumber,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.PaidCents,
		&i.BalanceCents,
		&i.Currency,
		&i.PaymentTerms,
		&i.DueDate,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderInvoiceID,
		&i.BillingAddressID,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.Metadata,
		&i.SentAt,
		&i.ViewedAt,
		&i.PaidAt,
		&i.VoidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentTermsID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.IsProforma,
	)
	return i, err
}

const getInvoiceByNumber = `-- name: GetInvoiceByNumber :one
SELECT id, tenant_id, user_id, invoice_number, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, paid_cents, balance_cents, currency, payment_terms, due_date, billing_customer_id, provider, provider_invoice_id, billing_address_id, customer_notes, internal_notes, metadata, sent_at, viewed_at, paid_at, voided_at, created_at, updated_at, payment_terms_id, billing_period_start, billing_period_end, is_proforma FROM invoices
WHERE tenant_id = $1
  AND invoice_number = $2
LIMIT 1
`

type GetInvoiceByNumberParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	InvoiceNumber string      `json:"invoice_number"`
}

// Get invoice by invoice number
func (q *Queries) GetInvoiceByNumber(ctx context.Context, arg GetInvoiceByNumberParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByNumber, arg.TenantID, arg.InvoiceNumber)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.InvoiceNumber,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.PaidCents,
		&i.BalanceCents,
		&i.Currency,
		&i.PaymentTerms,
		&i.DueDate,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderInvoiceID,
		&i.BillingAddressID,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.Metadata,
		&i.SentAt,
		&i.ViewedAt,
		&i.PaidAt,
		&i.VoidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentTermsID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.IsProforma,
	)
	return i, err
}

const getInvoiceByProviderID = `-- name: GetInvoiceByProviderID :one
SELECT id, tenant_id, user_id, invoice_number, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, paid_cents, balance_cents, currency, payment_terms, due_date, billing_customer_id, provider, provider_invoice_id, billing_address_id, customer_notes, internal_notes, metadata, sent_at, viewed_at, paid_at, voided_at, created_at, updated_at, payment_terms_id, billing_period_start, billing_period_end, is_proforma FROM invoices
WHERE tenant_id = $1
  AND provider = $2
  AND provider_invoice_id = $3
LIMIT 1
`

type GetInvoiceByProviderIDParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	Provider          pgtype.Text `json:"provider"`
	ProviderInvoiceID pgtype.Text `json:"provider_invoice_id"`
}

// Get invoice by billing provider ID (for Stripe webhook handling)
func (q *Queries) GetInvoiceByProviderID(ctx context.Context, arg GetInvoiceByProviderIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByProviderID, arg.TenantID, arg.Provider, arg.ProviderInvoiceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.InvoiceNumber,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.PaidCents,
		&i.BalanceCents,
		&i.Currency,
		&i.PaymentTerms,
		&i.DueDate,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderInvoiceID,
		&i.BillingAddressID,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.Metadata,
		&i.SentAt,
		&i.ViewedAt,
		&i.PaidAt,
		&i.VoidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentTermsID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.IsProforma,
	)
	return i, err
}

const getInvoiceForOrder = `-- name: GetInvoiceForOrder :one
SELECT i.id, i.tenant_id, i.user_id, i.invoice_number, i.status, i.subtotal_cents, i.tax_cents, i.shipping_cents, i.discount_cents, i.total_cents, i.paid_cents, i.balance_cents, i.currency, i.payment_terms, i.due_date, i.billing_customer_id, i.provider, i.provider_invoice_id, i.billing_address_id, i.customer_notes, i.internal_notes, i.metadata, i.sent_at, i.viewed_at, i.paid_at, i.voided_at, i.created_at, i.updated_at, i.payment_terms_id, i.billing_period_start, i.billing_period_end, i.is_proforma
FROM invoices i
JOIN invoice_orders io ON io.invoice_id = i.id
WHERE io.order_id = $1
LIMIT 1
`

// Get the invoice linked to a specific order (if any)
func (q *Queries) GetInvoiceForOrder(ctx context.Context, orderID pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceForOrder, orderID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.InvoiceNumber,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.PaidCents,
		&i.BalanceCents,
		&i.Currency,
		&i.PaymentTerms,
		&i.DueDate,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderInvoiceID,
		&i.BillingAddressID,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.Metadata,
		&i.SentAt,
		&i.ViewedAt,
		&i.PaidAt,
		&i.VoidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentTermsID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.IsProforma,
	)
	return i, err
}

const getInvoiceItems = `-- name: GetInvoiceItems :many
SELECT id, tenant_id, invoice_id, item_type, product_sku_id, order_id, description, quantity, unit_price_cents, total_price_cents, metadata, created_at, updated_at FROM invoice_items
WHERE invoice_id = $1
ORDER BY created_at ASC
`

// Get all items for an invoice
func (q *Queries) GetInvoiceItems(ctx context.Context, invoiceID pgtype.UUID) ([]InvoiceItem, error) {
	rows, err := q.db.Query(ctx, getInvoiceItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceItem{}
	for rows.Next() {
		var i InvoiceItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InvoiceID,
			&i.ItemType,
			&i.ProductSkuID,
			&i.OrderID,
			&i.Description,
			&i.Quantity,
			&i.UnitPriceCents,
			&i.TotalPriceCents,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceOrders = `-- name: GetInvoiceOrders :many
SELECT
    io.id,
    io.order_id,
    io.order_number,
    io.order_total_cents,
    io.created_at,
    o.status as order_status,
    o.fulfillment_status,
    o.created_at as order_created_at
FROM invoice_orders io
JOIN orders o ON o.id = io.order_id
WHERE io.invoice_id = $1
ORDER BY o.created_at ASC
`

type GetInvoiceOrdersRow struct {
	ID                pgtype.UUID        `json:"id"`
	OrderID           pgtype.UUID        `json:"order_id"`
	OrderNumber       string             `json:"order_number"`
	OrderTotalCents   int32              `json:"order_total_cents"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	OrderStatus       string             `json:"order_status"`
	FulfillmentStatus string             `json:"fulfillment_status"`
	OrderCreatedAt    pgtype.Timestamptz `json:"order_created_at"`
}

// Get all orders linked to an invoice
func (q *Queries) GetInvoiceOrders(ctx context.Context, invoiceID pgtype.UUID) ([]GetInvoiceOrdersRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceOrders, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceOrdersRow{}
	for rows.Next() {
		var i GetInvoiceOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.OrderNumber,
			&i.OrderTotalCents,
			&i.CreatedAt,
			&i.OrderStatus,
			&i.FulfillmentStatus,
			&i.OrderCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicePayments = `-- name: GetInvoicePayments :many
SELECT id, tenant_id, invoice_id, payment_id, amount_cents, payment_method, payment_reference, notes, metadata, payment_date, created_at, updated_at FROM invoice_payments
WHERE invoice_id = $1
ORDER BY payment_date DESC
`

// Get all payments for an invoice
func (q *Queries) GetInvoicePayments(ctx context.Context, invoiceID pgtype.UUID) ([]InvoicePayment, error) {
	rows, err := q.db.Query(ctx, getInvoicePayments, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoicePayment{}
	for rows.Next() {
		var i InvoicePayment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InvoiceID,
			&i.PaymentID,
			&i.AmountCents,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.Notes,
			&i.Metadata,
			&i.PaymentDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceStats = `-- name: GetInvoiceStats :one

SELECT
    COUNT(*) as total_invoices,
    COUNT(*) FILTER (WHERE status = 'sent') as sent_invoices,
    COUNT(*) FILTER (WHERE status = 'overdue') as overdue_invoices,
    COUNT(*) FILTER (WHERE status = 'paid') as paid_invoices,
    COALESCE(SUM(total_cents), 0) as total_invoiced_cents,
    COALESCE(SUM(balance_cents), 0) as total_outstanding_cents
FROM invoices
WHERE tenant_id = $1
  AND status NOT IN ('cancelled', 'void')
`

type GetInvoiceStatsRow struct {
	TotalInvoices         int64       `json:"total_invoices"`
	SentInvoices          int64       `json:"sent_invoices"`
	OverdueInvoices       int64       `json:"overdue_invoices"`
	PaidInvoices          int64       `json:"paid_invoices"`
	TotalInvoicedCents    interface{} `json:"total_invoiced_cents"`
	TotalOutstandingCents interface{} `json:"total_outstanding_cents"`
}

// =============================================================================
// STATISTICS
// =============================================================================
// Get invoice statistics for dashboard
func (q *Queries) GetInvoiceStats(ctx context.Context, tenantID pgtype.UUID) (GetInvoiceStatsRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceStats, tenantID)
	var i GetInvoiceStatsRow
	err := row.Scan(
		&i.TotalInvoices,
		&i.SentInvoices,
		&i.OverdueInvoices,
		&i.PaidInvoices,
		&i.TotalInvoicedCents,
		&i.TotalOutstandingCents,
	)
	return i, err
}

const getInvoiceWithDetails = `-- name: GetInvoiceWithDetails :one
SELECT
    i.id, i.tenant_id, i.user_id, i.invoice_number, i.status, i.subtotal_cents, i.tax_cents, i.shipping_cents, i.discount_cents, i.total_cents, i.paid_cents, i.balance_cents, i.currency, i.payment_terms, i.due_date, i.billing_customer_id, i.provider, i.provider_invoice_id, i.billing_address_id, i.customer_notes, i.internal_notes, i.metadata, i.sent_at, i.viewed_at, i.paid_at, i.voided_at, i.created_at, i.updated_at, i.payment_terms_id, i.billing_period_start, i.billing_period_end, i.is_proforma,
    u.email as customer_email,
    u.first_name as customer_first_name,
    u.last_name as customer_last_name,
    u.company_name,
    u.phone as customer_phone,
    pt.name as payment_terms_name,
    pt.days as payment_terms_days,
    ba.full_name as billing_name,
    ba.company as billing_company,
    ba.address_line1 as billing_address_line1,
    ba.address_line2 as billing_address_line2,
    ba.city as billing_city,
    ba.state as billing_state,
    ba.postal_code as billing_postal_code,
    ba.country as billing_country
FROM invoices i
JOIN users u ON u.id = i.user_id
LEFT JOIN payment_terms pt ON pt.id = i.payment_terms_id
LEFT JOIN addresses ba ON ba.id = i.billing_address_id
WHERE i.tenant_id = $1
  AND i.id = $2
LIMIT 1
`

type GetInvoiceWithDetailsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

type GetInvoiceWithDetailsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	UserID              pgtype.UUID        `json:"user_id"`
	InvoiceNumber       string             `json:"invoice_number"`
	Status              string             `json:"status"`
	SubtotalCents       int32              `json:"subtotal_cents"`
	TaxCents            int32              `json:"tax_cents"`
	ShippingCents       int32              `json:"shipping_cents"`
	DiscountCents       int32              `json:"discount_cents"`
	TotalCents          int32              `json:"total_cents"`
	PaidCents           int32              `json:"paid_cents"`
	BalanceCents        int32              `json:"balance_cents"`
	Currency            string             `json:"currency"`
	PaymentTerms        string             `json:"payment_terms"`
	DueDate             pgtype.Date        `json:"due_date"`
	BillingCustomerID   pgtype.UUID        `json:"billing_customer_id"`
	Provider            pgtype.Text        `json:"provider"`
	ProviderInvoiceID   pgtype.Text        `json:"provider_invoice_id"`
	BillingAddressID    pgtype.UUID        `json:"billing_address_id"`
	CustomerNotes       pgtype.Text        `json:"customer_notes"`
	InternalNotes       pgtype.Text        `json:"internal_notes"`
	Metadata            []byte             `json:"metadata"`
	SentAt              pgtype.Timestamptz `json:"sent_at"`
	ViewedAt            pgtype.Timestamptz `json:"viewed_at"`
	PaidAt              pgtype.Timestamptz `json:"paid_at"`
	VoidedAt            pgtype.Timestamptz `json:"voided_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	PaymentTermsID      pgtype.UUID        `json:"payment_terms_id"`
	BillingPeriodStart  pgtype.Date        `json:"billing_period_start"`
	BillingPeriodEnd    pgtype.Date        `json:"billing_period_end"`
	IsProforma          bool               `json:"is_proforma"`
	CustomerEmail       string             `json:"customer_email"`
	CustomerFirstName   pgtype.Text        `json:"customer_first_name"`
	CustomerLastName    pgtype.Text        `json:"customer_last_name"`
	CompanyName         pgtype.Text        `json:"company_name"`
	CustomerPhone       pgtype.Text        `json:"customer_phone"`
	PaymentTermsName    pgtype.Text        `json:"payment_terms_name"`
	PaymentTermsDays    pgtype.Int4        `json:"payment_terms_days"`
	BillingName         pgtype.Text        `json:"billing_name"`
	BillingCompany      pgtype.Text        `json:"billing_company"`
	BillingAddressLine1 pgtype.Text        `json:"billing_address_line1"`
	BillingAddressLine2 pgtype.Text        `json:"billing_address_line2"`
	BillingCity         pgtype.Text        `json:"billing_city"`
	BillingState        pgtype.Text        `json:"billing_state"`
	BillingPostalCode   pgtype.Text        `json:"billing_postal_code"`
	BillingCountry      pgtype.Text        `json:"billing_country"`
}

// Get complete invoice with customer and payment terms details
func (q *Queries) GetInvoiceWithDetails(ctx context.Context, arg GetInvoiceWithDetailsParams) (GetInvoiceWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceWithDetails, arg.TenantID, arg.ID)
	var i GetInvoiceWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.InvoiceNumber,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.PaidCents,
		&i.BalanceCents,
		&i.Currency,
		&i.PaymentTerms,
		&i.DueDate,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderInvoiceID,
		&i.BillingAddressID,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.Metadata,
		&i.SentAt,
		&i.ViewedAt,
		&i.PaidAt,
		&i.VoidedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaymentTermsID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.IsProforma,
		&i.CustomerEmail,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.CompanyName,
		&i.CustomerPhone,
		&i.PaymentTermsName,
		&i.PaymentTermsDays,
		&i.BillingName,
		&i.BillingCompany,
		&i.BillingAddressLine1,
		&i.BillingAddressLine2,
		&i.BillingCity,
		&i.BillingState,
		&i.BillingPostalCode,
		&i.BillingCountry,
	)
	return i, err
}

const getUninvoicedOrdersForUser = `-- name: GetUninvoicedOrdersForUser :many

SELECT o.id, o.tenant_id, o.user_id, o.order_number, o.order_type, o.status, o.subtotal_cents, o.tax_cents, o.shipping_cents, o.discount_cents, o.total_cents, o.currency, o.payment_id, o.payment_status, o.shipping_address_id, o.billing_address_id, o.shipping_method, o.shipping_carrier, o.customer_notes, o.internal_notes, o.fulfillment_status, o.cart_id, o.subscription_id, o.metadata, o.paid_at, o.shipped_at, o.delivered_at, o.cancelled_at, o.created_at, o.updated_at, o.customer_po_number, o.requested_delivery_date
FROM orders o
LEFT JOIN invoice_orders io ON io.order_id = o.id
WHERE o.tenant_id = $1
  AND o.user_id = $2
  AND o.order_type = 'wholesale'
  AND o.status IN ('paid', 'processing', 'shipped', 'delivered')
  AND io.id IS NULL
ORDER BY o.created_at ASC
`

type GetUninvoicedOrdersForUserParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

// =============================================================================
// CONSOLIDATED BILLING QUERIES
// =============================================================================
// Get orders that haven't been invoiced yet for a user
// Used for generating consolidated invoices
func (q *Queries) GetUninvoicedOrdersForUser(ctx context.Context, arg GetUninvoicedOrdersForUserParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getUninvoicedOrdersForUser, arg.TenantID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.OrderNumber,
			&i.OrderType,
			&i.Status,
			&i.SubtotalCents,
			&i.TaxCents,
			&i.ShippingCents,
			&i.DiscountCents,
			&i.TotalCents,
			&i.Currency,
			&i.PaymentID,
			&i.PaymentStatus,
			&i.ShippingAddressID,
			&i.BillingAddressID,
			&i.ShippingMethod,
			&i.ShippingCarrier,
			&i.CustomerNotes,
			&i.InternalNotes,
			&i.FulfillmentStatus,
			&i.CartID,
			&i.SubscriptionID,
			&i.Metadata,
			&i.PaidAt,
			&i.ShippedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerPoNumber,
			&i.RequestedDeliveryDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUninvoicedOrdersInPeriod = `-- name: GetUninvoicedOrdersInPeriod :many
SELECT o.id, o.tenant_id, o.user_id, o.order_number, o.order_type, o.status, o.subtotal_cents, o.tax_cents, o.shipping_cents, o.discount_cents, o.total_cents, o.currency, o.payment_id, o.payment_status, o.shipping_address_id, o.billing_address_id, o.shipping_method, o.shipping_carrier, o.customer_notes, o.internal_notes, o.fulfillment_status, o.cart_id, o.subscription_id, o.metadata, o.paid_at, o.shipped_at, o.delivered_at, o.cancelled_at, o.created_at, o.updated_at, o.customer_po_number, o.requested_delivery_date
FROM orders o
LEFT JOIN invoice_orders io ON io.order_id = o.id
WHERE o.tenant_id = $1
  AND o.user_id = $2
  AND o.order_type = 'wholesale'
  AND o.status IN ('paid', 'processing', 'shipped', 'delivered')
  AND o.created_at >= $3
  AND o.created_at < $4
  AND io.id IS NULL
ORDER BY o.created_at ASC
`

type GetUninvoicedOrdersInPeriodParams struct {
	TenantID    pgtype.UUID        `json:"tenant_id"`
	UserID      pgtype.UUID        `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

// Get uninvoiced orders within a billing period
func (q *Queries) GetUninvoicedOrdersInPeriod(ctx context.Context, arg GetUninvoicedOrdersInPeriodParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getUninvoicedOrdersInPeriod,
		arg.TenantID,
		arg.UserID,
		arg.CreatedAt,
		arg.CreatedAt_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.OrderNumber,
			&i.OrderType,
			&i.Status,
			&i.SubtotalCents,
			&i.TaxCents,
			&i.ShippingCents,
			&i.DiscountCents,
			&i.TotalCents,
			&i.Currency,
			&i.PaymentID,
			&i.PaymentStatus,
			&i.ShippingAddressID,
			&i.BillingAddressID,
			&i.ShippingMethod,
			&i.ShippingCarrier,
			&i.CustomerNotes,
			&i.InternalNotes,
			&i.FulfillmentStatus,
			&i.CartID,
			&i.SubscriptionID,
			&i.Metadata,
			&i.PaidAt,
			&i.ShippedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerPoNumber,
			&i.RequestedDeliveryDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoices = `-- name: ListInvoices :many
SELECT
    i.id,
    i.tenant_id,
    i.invoice_number,
    i.status,
    i.total_cents,
    i.paid_cents,
    i.balance_cents,
    i.currency,
    i.payment_terms,
    i.due_date,
    i.created_at,
    i.sent_at,
    i.paid_at,
    i.is_proforma,
    u.email as customer_email,
    u.company_name,
    CONCAT(u.first_name, ' ', u.last_name)::TEXT as customer_name
FROM invoices i
JOIN users u ON u.id = i.user_id
WHERE i.tenant_id = $1
ORDER BY i.created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListInvoicesRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	InvoiceNumber string             `json:"invoice_number"`
	Status        string             `json:"status"`
	TotalCents    int32              `json:"total_cents"`
	PaidCents     int32              `json:"paid_cents"`
	BalanceCents  int32              `json:"balance_cents"`
	Currency      string             `json:"currency"`
	PaymentTerms  string             `json:"payment_terms"`
	DueDate       pgtype.Date        `json:"due_date"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	SentAt        pgtype.Timestamptz `json:"sent_at"`
	PaidAt        pgtype.Timestamptz `json:"paid_at"`
	IsProforma    bool               `json:"is_proforma"`
	CustomerEmail string             `json:"customer_email"`
	CompanyName   pgtype.Text        `json:"company_name"`
	CustomerName  string             `json:"customer_name"`
}

// List all invoices for admin with customer details
func (q *Queries) ListInvoices(ctx context.Context, arg ListInvoicesParams) ([]ListInvoicesRow, error) {
	rows, err := q.db.Query(ctx, listInvoices, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvoicesRow{}
	for rows.Next() {
		var i ListInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InvoiceNumber,
			&i.Status,
			&i.TotalCents,
			&i.PaidCents,
			&i.BalanceCents,
			&i.Currency,
			&i.PaymentTerms,
			&i.DueDate,
			&i.CreatedAt,
			&i.SentAt,
			&i.PaidAt,
			&i.IsProforma,
			&i.CustomerEmail,
			&i.CompanyName,
			&i.CustomerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByStatus = `-- name: ListInvoicesByStatus :many
SELECT
    i.id,
    i.tenant_id,
    i.invoice_number,
    i.status,
    i.total_cents,
    i.paid_cents,
    i.balance_cents,
    i.currency,
    i.due_date,
    i.created_at,
    u.email as customer_email,
    u.company_name
FROM invoices i
JOIN users u ON u.id = i.user_id
WHERE i.tenant_id = $1
  AND i.status = $2
ORDER BY i.due_date ASC
`

type ListInvoicesByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

type ListInvoicesByStatusRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	InvoiceNumber string             `json:"invoice_number"`
	Status        string             `json:"status"`
	TotalCents    int32              `json:"total_cents"`
	PaidCents     int32              `json:"paid_cents"`
	BalanceCents  int32              `json:"balance_cents"`
	Currency      string             `json:"currency"`
	DueDate       pgtype.Date        `json:"due_date"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CustomerEmail string             `json:"customer_email"`
	CompanyName   pgtype.Text        `json:"company_name"`
}

// List invoices filtered by status
func (q *Queries) ListInvoicesByStatus(ctx context.Context, arg ListInvoicesByStatusParams) ([]ListInvoicesByStatusRow, error) {
	rows, err := q.db.Query(ctx, listInvoicesByStatus, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvoicesByStatusRow{}
	for rows.Next() {
		var i ListInvoicesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InvoiceNumber,
			&i.Status,
			&i.TotalCents,
			&i.PaidCents,
			&i.BalanceCents,
			&i.Currency,
			&i.DueDate,
			&i.CreatedAt,
			&i.CustomerEmail,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesForUser = `-- name: ListInvoicesForUser :many

SELECT id, tenant_id, user_id, invoice_number, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, paid_cents, balance_cents, currency, payment_terms, due_date, billing_customer_id, provider, provider_invoice_id, billing_address_id, customer_notes, internal_notes, metadata, sent_at, viewed_at, paid_at, voided_at, created_at, updated_at, payment_terms_id, billing_period_start, billing_period_end, is_proforma FROM invoices
WHERE tenant_id = $1
  AND user_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesForUserParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// =============================================================================
// LISTING QUERIES
// =============================================================================
// List invoices for a customer
func (q *Queries) ListInvoicesForUser(ctx context.Context, arg ListInvoicesForUserParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesForUser,
		arg.TenantID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.InvoiceNumber,
			&i.Status,
			&i.SubtotalCents,
			&i.TaxCents,
			&i.ShippingCents,
			&i.DiscountCents,
			&i.TotalCents,
			&i.PaidCents,
			&i.BalanceCents,
			&i.Currency,
			&i.PaymentTerms,
			&i.DueDate,
			&i.BillingCustomerID,
			&i.Provider,
			&i.ProviderInvoiceID,
			&i.BillingAddressID,
			&i.CustomerNotes,
			&i.InternalNotes,
			&i.Metadata,
			&i.SentAt,
			&i.ViewedAt,
			&i.PaidAt,
			&i.VoidedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaymentTermsID,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.IsProforma,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverdueInvoices = `-- name: ListOverdueInvoices :many
SELECT
    i.id,
    i.tenant_id,
    i.invoice_number,
    i.status,
    i.total_cents,
    i.balance_cents,
    i.currency,
    i.due_date,
    i.created_at,
    u.id as user_id,
    u.email as customer_email,
    u.company_name,
    u.email_invoices
FROM invoices i
JOIN users u ON u.id = i.user_id
WHERE i.tenant_id = $1
  AND i.status NOT IN ('paid', 'cancelled', 'void')
  AND i.due_date < CURRENT_DATE
ORDER BY i.due_date ASC
`

type ListOverdueInvoicesRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	InvoiceNumber string             `json:"invoice_number"`
	Status        string             `json:"status"`
	TotalCents    int32              `json:"total_cents"`
	BalanceCents  int32              `json:"balance_cents"`
	Currency      string             `json:"currency"`
	DueDate       pgtype.Date        `json:"due_date"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UserID        pgtype.UUID        `json:"user_id"`
	CustomerEmail string             `json:"customer_email"`
	CompanyName   pgtype.Text        `json:"company_name"`
	EmailInvoices pgtype.Text        `json:"email_invoices"`
}

// List invoices that are past due
func (q *Queries) ListOverdueInvoices(ctx context.Context, tenantID pgtype.UUID) ([]ListOverdueInvoicesRow, error) {
	rows, err := q.db.Query(ctx, listOverdueInvoices, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOverdueInvoicesRow{}
	for rows.Next() {
		var i ListOverdueInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InvoiceNumber,
			&i.Status,
			&i.TotalCents,
			&i.BalanceCents,
			&i.Currency,
			&i.DueDate,
			&i.CreatedAt,
			&i.UserID,
			&i.CustomerEmail,
			&i.CompanyName,
			&i.EmailInvoices,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInvoiceViewed = `-- name: MarkInvoiceViewed :exec
UPDATE invoices
SET
    viewed_at = COALESCE(viewed_at, NOW()),
    status = CASE WHEN status = 'sent' THEN 'viewed' ELSE status END,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type MarkInvoiceViewedParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Mark invoice as viewed (first view only)
func (q *Queries) MarkInvoiceViewed(ctx context.Context, arg MarkInvoiceViewedParams) error {
	_, err := q.db.Exec(ctx, markInvoiceViewed, arg.TenantID, arg.ID)
	return err
}

const updateInvoiceProviderID = `-- name: UpdateInvoiceProviderID :exec
UPDATE invoices
SET
    provider = $3,
    provider_invoice_id = $4,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateInvoiceProviderIDParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	ID                pgtype.UUID `json:"id"`
	Provider          pgtype.Text `json:"provider"`
	ProviderInvoiceID pgtype.Text `json:"provider_invoice_id"`
}

// Link invoice to billing provider
func (q *Queries) UpdateInvoiceProviderID(ctx context.Context, arg UpdateInvoiceProviderIDParams) error {
	_, err := q.db.Exec(ctx, updateInvoiceProviderID,
		arg.TenantID,
		arg.ID,
		arg.Provider,
		arg.ProviderInvoiceID,
	)
	return err
}

const updateInvoiceStatus = `-- name: UpdateInvoiceStatus :exec
UPDATE invoices
SET
    status = $3,
    sent_at = CASE WHEN $3 = 'sent' AND sent_at IS NULL THEN NOW() ELSE sent_at END,
    voided_at = CASE WHEN $3 = 'void' THEN NOW() ELSE voided_at END,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateInvoiceStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
	Status   string      `json:"status"`
}

// Update invoice status
func (q *Queries) UpdateInvoiceStatus(ctx context.Context, arg UpdateInvoiceStatusParams) error {
	_, err := q.db.Exec(ctx, updateInvoiceStatus, arg.TenantID, arg.ID, arg.Status)
	return err
}
