// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: onboarding.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAccountActivated = `-- name: CheckAccountActivated :one

SELECT EXISTS(
    SELECT 1 FROM tenant_operators
    WHERE tenant_id = $1
      AND status = 'active'
      AND password_hash IS NOT NULL
) as is_complete
`

// ============================================================================
// ONBOARDING VALIDATION QUERIES
// ============================================================================
// These queries check actual data to determine completion status.
// Each returns a single boolean indicating if the step is complete.
// Validation: account_activated
// True if any operator for this tenant is active (has set password and can log in)
func (q *Queries) CheckAccountActivated(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkAccountActivated, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkBusinessInfo = `-- name: CheckBusinessInfo :one
SELECT EXISTS(
    SELECT 1 FROM tenants
    WHERE id = $1
      AND name IS NOT NULL
      AND name != ''
      AND email IS NOT NULL
      AND email != ''
) as is_complete
`

// Validation: business_info
// True if tenant has name and email set
func (q *Queries) CheckBusinessInfo(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkBusinessInfo, id)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkCoffeeAttributes = `-- name: CheckCoffeeAttributes :one
SELECT NOT EXISTS(
    SELECT 1 FROM products
    WHERE tenant_id = $1
      AND status = 'active'
      AND (origin IS NULL OR origin = '' OR roast_level IS NULL OR roast_level = '')
) as is_complete
`

// Validation: coffee_attributes
// True if all active products have origin and roast_level set
// Returns true if there are no active products (vacuous truth)
func (q *Queries) CheckCoffeeAttributes(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkCoffeeAttributes, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkEmailConfigured = `-- name: CheckEmailConfigured :one
SELECT EXISTS(
    SELECT 1 FROM tenant_provider_configs
    WHERE tenant_id = $1
      AND type = 'email'
      AND is_active = true
) as is_complete
`

// Validation: email_configured
// True if any email provider is configured and active
func (q *Queries) CheckEmailConfigured(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailConfigured, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkFirstProduct = `-- name: CheckFirstProduct :one
SELECT EXISTS(
    SELECT 1 FROM products
    WHERE tenant_id = $1
      AND status = 'active'
) as is_complete
`

// Validation: first_product
// True if at least one active product exists
func (q *Queries) CheckFirstProduct(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkFirstProduct, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkFirstSKU = `-- name: CheckFirstSKU :one
SELECT EXISTS(
    SELECT 1 FROM product_skus ps
    JOIN products p ON p.id = ps.product_id
    WHERE p.tenant_id = $1
      AND p.status = 'active'
) as is_complete
`

// Validation: first_sku
// True if at least one SKU exists for an active product
func (q *Queries) CheckFirstSKU(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkFirstSKU, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkPaymentTerms = `-- name: CheckPaymentTerms :one
SELECT EXISTS(
    SELECT 1 FROM payment_terms
    WHERE tenant_id = $1
      AND is_default = true
) as is_complete
`

// Validation: payment_terms
// True if at least one payment term is marked as default
func (q *Queries) CheckPaymentTerms(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkPaymentTerms, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkPricingSet = `-- name: CheckPricingSet :one
SELECT NOT EXISTS(
    SELECT 1 FROM product_skus ps
    JOIN products p ON p.id = ps.product_id
    JOIN price_lists pl ON pl.tenant_id = p.tenant_id AND pl.list_type = 'default'
    LEFT JOIN price_list_entries ple ON ple.price_list_id = pl.id AND ple.product_sku_id = ps.id
    WHERE p.tenant_id = $1
      AND p.status = 'active'
      AND ple.id IS NULL
) as is_complete
`

// Validation: pricing_set
// True if all SKUs of active products have price list entries in the default price list
// Returns true if there are no active products (vacuous truth - nothing to price)
func (q *Queries) CheckPricingSet(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkPricingSet, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkProductImages = `-- name: CheckProductImages :one
SELECT NOT EXISTS(
    SELECT p.id FROM products p
    LEFT JOIN product_images pi ON pi.product_id = p.id
    WHERE p.tenant_id = $1
      AND p.status = 'active'
    GROUP BY p.id
    HAVING COUNT(pi.id) = 0
) as is_complete
`

// Validation: product_images
// True if all active products have at least one image
// Returns true if there are no active products (vacuous truth)
func (q *Queries) CheckProductImages(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkProductImages, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkShippingConfigured = `-- name: CheckShippingConfigured :one
SELECT EXISTS(
    SELECT 1 FROM shipping_methods
    WHERE tenant_id = $1
      AND is_active = true
) as is_complete
`

// Validation: shipping_configured
// True if at least one active shipping method exists
func (q *Queries) CheckShippingConfigured(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkShippingConfigured, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkStripeConnected = `-- name: CheckStripeConnected :one
SELECT EXISTS(
    SELECT 1 FROM tenant_provider_configs
    WHERE tenant_id = $1
      AND type = 'billing'
      AND name = 'stripe'
      AND is_active = true
      AND config_encrypted IS NOT NULL
) as is_complete
`

// Validation: stripe_connected
// True if Stripe billing provider is configured and active
func (q *Queries) CheckStripeConnected(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkStripeConnected, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkTaxConfigured = `-- name: CheckTaxConfigured :one
SELECT EXISTS(
    SELECT 1 FROM tenant_provider_configs
    WHERE tenant_id = $1
      AND type = 'tax'
      AND is_active = true
) as is_complete
`

// Validation: tax_configured
// True if any tax provider is configured and active (including 'no_tax')
func (q *Queries) CheckTaxConfigured(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkTaxConfigured, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkWarehouseAddress = `-- name: CheckWarehouseAddress :one
SELECT EXISTS(
    SELECT 1 FROM addresses
    WHERE tenant_id = $1
      AND address_type = 'warehouse'
) as is_complete
`

// Validation: warehouse_address
// True if a warehouse address exists
func (q *Queries) CheckWarehouseAddress(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkWarehouseAddress, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const checkWholesalePricing = `-- name: CheckWholesalePricing :one
SELECT EXISTS(
    SELECT 1 FROM price_lists pl
    JOIN price_list_entries ple ON ple.price_list_id = pl.id
    WHERE pl.tenant_id = $1
      AND pl.list_type = 'wholesale'
) as is_complete
`

// Validation: wholesale_pricing
// True if at least one wholesale price list with entries exists
func (q *Queries) CheckWholesalePricing(ctx context.Context, tenantID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkWholesalePricing, tenantID)
	var is_complete bool
	err := row.Scan(&is_complete)
	return is_complete, err
}

const getAllOnboardingValidations = `-- name: GetAllOnboardingValidations :one

WITH tenant_param AS (
    SELECT $1::uuid AS tid
)
SELECT
    -- Phase 1: Critical Path (Required)
    EXISTS(
        SELECT 1 FROM tenant_operators, tenant_param tp
        WHERE tenant_operators.tenant_id = tp.tid AND status = 'active' AND password_hash IS NOT NULL
    ) as account_activated,

    EXISTS(
        SELECT 1 FROM tenant_provider_configs, tenant_param tp
        WHERE tenant_provider_configs.tenant_id = tp.tid AND type = 'billing' AND name = 'stripe' AND is_active = true
    ) as stripe_connected,

    EXISTS(
        SELECT 1 FROM tenant_provider_configs, tenant_param tp
        WHERE tenant_provider_configs.tenant_id = tp.tid AND type = 'email' AND is_active = true
    ) as email_configured,

    EXISTS(
        SELECT 1 FROM products, tenant_param tp
        WHERE products.tenant_id = tp.tid AND status = 'active'
    ) as first_product,

    EXISTS(
        SELECT 1 FROM product_skus ps
        JOIN products p ON p.id = ps.product_id
        CROSS JOIN tenant_param tp
        WHERE p.tenant_id = tp.tid AND p.status = 'active'
    ) as first_sku,

    NOT EXISTS(
        SELECT 1 FROM product_skus ps
        JOIN products p ON p.id = ps.product_id
        JOIN price_lists pl ON pl.tenant_id = p.tenant_id AND pl.list_type = 'default'
        LEFT JOIN price_list_entries ple ON ple.price_list_id = pl.id AND ple.product_sku_id = ps.id
        CROSS JOIN tenant_param tp
        WHERE p.tenant_id = tp.tid AND p.status = 'active' AND ple.id IS NULL
    ) as pricing_set,

    EXISTS(
        SELECT 1 FROM shipping_methods, tenant_param tp
        WHERE shipping_methods.tenant_id = tp.tid AND is_active = true
    ) as shipping_configured,

    EXISTS(
        SELECT 1 FROM tenant_provider_configs, tenant_param tp
        WHERE tenant_provider_configs.tenant_id = tp.tid AND type = 'tax' AND is_active = true
    ) as tax_configured,

    -- Phase 2: Recommended (Optional)
    EXISTS(
        SELECT 1 FROM tenants, tenant_param tp
        WHERE tenants.id = tp.tid AND name IS NOT NULL AND name != '' AND email IS NOT NULL AND email != ''
    ) as business_info,

    EXISTS(
        SELECT 1 FROM addresses, tenant_param tp
        WHERE addresses.tenant_id = tp.tid AND address_type = 'warehouse'
    ) as warehouse_address,

    NOT EXISTS(
        SELECT p.id FROM products p
        CROSS JOIN tenant_param tp
        LEFT JOIN product_images pi ON pi.product_id = p.id
        WHERE p.tenant_id = tp.tid AND p.status = 'active'
        GROUP BY p.id HAVING COUNT(pi.id) = 0
    ) as product_images,

    NOT EXISTS(
        SELECT 1 FROM products, tenant_param tp
        WHERE products.tenant_id = tp.tid AND status = 'active'
        AND (origin IS NULL OR origin = '' OR roast_level IS NULL OR roast_level = '')
    ) as coffee_attributes,

    -- Phase 3: Wholesale (Optional)
    EXISTS(
        SELECT 1 FROM price_lists pl
        JOIN price_list_entries ple ON ple.price_list_id = pl.id
        CROSS JOIN tenant_param tp
        WHERE pl.tenant_id = tp.tid AND pl.list_type = 'wholesale'
    ) as wholesale_pricing,

    EXISTS(
        SELECT 1 FROM payment_terms, tenant_param tp
        WHERE payment_terms.tenant_id = tp.tid AND is_default = true
    ) as payment_terms
`

type GetAllOnboardingValidationsRow struct {
	AccountActivated   bool `json:"account_activated"`
	StripeConnected    bool `json:"stripe_connected"`
	EmailConfigured    bool `json:"email_configured"`
	FirstProduct       bool `json:"first_product"`
	FirstSku           bool `json:"first_sku"`
	PricingSet         bool `json:"pricing_set"`
	ShippingConfigured bool `json:"shipping_configured"`
	TaxConfigured      bool `json:"tax_configured"`
	BusinessInfo       bool `json:"business_info"`
	WarehouseAddress   bool `json:"warehouse_address"`
	ProductImages      bool `json:"product_images"`
	CoffeeAttributes   bool `json:"coffee_attributes"`
	WholesalePricing   bool `json:"wholesale_pricing"`
	PaymentTerms       bool `json:"payment_terms"`
}

// ============================================================================
// COMBINED VALIDATION QUERY (PERFORMANCE OPTIMIZATION)
// ============================================================================
// Single query that returns all validation results at once.
// Use this instead of 14 separate queries for better performance.
// Uses a CTE to anchor the tenant_id parameter and avoid ambiguous references.
func (q *Queries) GetAllOnboardingValidations(ctx context.Context, dollar_1 pgtype.UUID) (GetAllOnboardingValidationsRow, error) {
	row := q.db.QueryRow(ctx, getAllOnboardingValidations, dollar_1)
	var i GetAllOnboardingValidationsRow
	err := row.Scan(
		&i.AccountActivated,
		&i.StripeConnected,
		&i.EmailConfigured,
		&i.FirstProduct,
		&i.FirstSku,
		&i.PricingSet,
		&i.ShippingConfigured,
		&i.TaxConfigured,
		&i.BusinessInfo,
		&i.WarehouseAddress,
		&i.ProductImages,
		&i.CoffeeAttributes,
		&i.WholesalePricing,
		&i.PaymentTerms,
	)
	return i, err
}

const getSkippedItems = `-- name: GetSkippedItems :many

SELECT id, tenant_id, item_id, skipped_at, skipped_by
FROM onboarding_item_skips
WHERE tenant_id = $1
`

// ============================================================================
// ONBOARDING SKIP TRACKING
// ============================================================================
// Get all skipped items for a tenant
func (q *Queries) GetSkippedItems(ctx context.Context, tenantID pgtype.UUID) ([]OnboardingItemSkip, error) {
	rows, err := q.db.Query(ctx, getSkippedItems, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OnboardingItemSkip{}
	for rows.Next() {
		var i OnboardingItemSkip
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ItemID,
			&i.SkippedAt,
			&i.SkippedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isItemSkipped = `-- name: IsItemSkipped :one
SELECT EXISTS(
    SELECT 1 FROM onboarding_item_skips
    WHERE tenant_id = $1 AND item_id = $2
) as is_skipped
`

type IsItemSkippedParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ItemID   string      `json:"item_id"`
}

// Check if a specific item is skipped
func (q *Queries) IsItemSkipped(ctx context.Context, arg IsItemSkippedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isItemSkipped, arg.TenantID, arg.ItemID)
	var is_skipped bool
	err := row.Scan(&is_skipped)
	return is_skipped, err
}

const skipItem = `-- name: SkipItem :one
INSERT INTO onboarding_item_skips (tenant_id, item_id, skipped_by)
VALUES ($1, $2, $3)
ON CONFLICT (tenant_id, item_id) DO UPDATE SET
    skipped_at = NOW(),
    skipped_by = EXCLUDED.skipped_by
RETURNING id, tenant_id, item_id, skipped_at, skipped_by
`

type SkipItemParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ItemID    string      `json:"item_id"`
	SkippedBy pgtype.UUID `json:"skipped_by"`
}

// Mark an item as skipped (idempotent - updates timestamp if already skipped)
func (q *Queries) SkipItem(ctx context.Context, arg SkipItemParams) (OnboardingItemSkip, error) {
	row := q.db.QueryRow(ctx, skipItem, arg.TenantID, arg.ItemID, arg.SkippedBy)
	var i OnboardingItemSkip
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ItemID,
		&i.SkippedAt,
		&i.SkippedBy,
	)
	return i, err
}

const unskipItem = `-- name: UnskipItem :exec
DELETE FROM onboarding_item_skips
WHERE tenant_id = $1 AND item_id = $2
`

type UnskipItemParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ItemID   string      `json:"item_id"`
}

// Remove skip flag (if user wants to complete the item)
func (q *Queries) UnskipItem(ctx context.Context, arg UnskipItemParams) error {
	_, err := q.db.Exec(ctx, unskipItem, arg.TenantID, arg.ItemID)
	return err
}
