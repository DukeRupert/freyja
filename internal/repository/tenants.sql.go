// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenants.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateTenant = `-- name: ActivateTenant :exec
UPDATE tenants
SET
    status = 'active',
    updated_at = NOW()
WHERE id = $1
  AND status = 'pending'
`

// Activate a pending tenant after password setup
func (q *Queries) ActivateTenant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, activateTenant, id)
	return err
}

const cancelTenant = `-- name: CancelTenant :exec
UPDATE tenants
SET
    status = 'cancelled',
    updated_at = NOW()
WHERE id = $1
`

// Cancel a tenant subscription
func (q *Queries) CancelTenant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, cancelTenant, id)
	return err
}

const clearTenantGracePeriod = `-- name: ClearTenantGracePeriod :exec
UPDATE tenants
SET
    status = 'active',
    grace_period_started_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

// Clear grace period after successful payment
func (q *Queries) ClearTenantGracePeriod(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearTenantGracePeriod, id)
	return err
}

const countTenantsByStatus = `-- name: CountTenantsByStatus :one
SELECT COUNT(*)
FROM tenants
WHERE status = $1
`

// Count tenants by status
func (q *Queries) CountTenantsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countTenantsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTenant = `-- name: CreateTenant :one

INSERT INTO tenants (
    name,
    slug,
    email,
    status
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
`

type CreateTenantParams struct {
	Name   string `json:"name"`
	Slug   string `json:"slug"`
	Email  string `json:"email"`
	Status string `json:"status"`
}

// Tenants: Coffee roasters using the platform (multi-tenant root)
// Create a new tenant (called after Stripe checkout)
func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant,
		arg.Name,
		arg.Slug,
		arg.Email,
		arg.Status,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Email,
		&i.Phone,
		&i.Website,
		&i.BusinessName,
		&i.TaxID,
		&i.Settings,
		&i.Status,
		&i.TrialEndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.GracePeriodStartedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
FROM tenants
WHERE id = $1
LIMIT 1
`

// Get tenant by ID
func (q *Queries) GetTenantByID(ctx context.Context, id pgtype.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Email,
		&i.Phone,
		&i.Website,
		&i.BusinessName,
		&i.TaxID,
		&i.Settings,
		&i.Status,
		&i.TrialEndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.GracePeriodStartedAt,
	)
	return i, err
}

const getTenantBySlug = `-- name: GetTenantBySlug :one
SELECT id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
FROM tenants
WHERE slug = $1
LIMIT 1
`

// Get tenant by slug (for subdomain/path routing)
func (q *Queries) GetTenantBySlug(ctx context.Context, slug string) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantBySlug, slug)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Email,
		&i.Phone,
		&i.Website,
		&i.BusinessName,
		&i.TaxID,
		&i.Settings,
		&i.Status,
		&i.TrialEndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.GracePeriodStartedAt,
	)
	return i, err
}

const getTenantByStripeCustomerID = `-- name: GetTenantByStripeCustomerID :one
SELECT id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
FROM tenants
WHERE stripe_customer_id = $1
LIMIT 1
`

// Get tenant by Stripe customer ID (for webhook processing)
func (q *Queries) GetTenantByStripeCustomerID(ctx context.Context, stripeCustomerID pgtype.Text) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByStripeCustomerID, stripeCustomerID)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Email,
		&i.Phone,
		&i.Website,
		&i.BusinessName,
		&i.TaxID,
		&i.Settings,
		&i.Status,
		&i.TrialEndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.GracePeriodStartedAt,
	)
	return i, err
}

const getTenantByStripeSubscriptionID = `-- name: GetTenantByStripeSubscriptionID :one
SELECT id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
FROM tenants
WHERE stripe_subscription_id = $1
LIMIT 1
`

// Get tenant by Stripe subscription ID (for webhook processing)
func (q *Queries) GetTenantByStripeSubscriptionID(ctx context.Context, stripeSubscriptionID pgtype.Text) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByStripeSubscriptionID, stripeSubscriptionID)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Email,
		&i.Phone,
		&i.Website,
		&i.BusinessName,
		&i.TaxID,
		&i.Settings,
		&i.Status,
		&i.TrialEndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.GracePeriodStartedAt,
	)
	return i, err
}

const getTenantsWithExpiredGracePeriod = `-- name: GetTenantsWithExpiredGracePeriod :many
SELECT id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
FROM tenants
WHERE status = 'past_due'
  AND grace_period_started_at IS NOT NULL
  AND grace_period_started_at <= NOW() - INTERVAL '168 hours'
ORDER BY grace_period_started_at ASC
`

// Get tenants whose grace period has expired (for suspension job)
// Grace period is 7 days (168 hours)
func (q *Queries) GetTenantsWithExpiredGracePeriod(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, getTenantsWithExpiredGracePeriod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Email,
			&i.Phone,
			&i.Website,
			&i.BusinessName,
			&i.TaxID,
			&i.Settings,
			&i.Status,
			&i.TrialEndsAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.GracePeriodStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveTenants = `-- name: ListActiveTenants :many
SELECT id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
FROM tenants
WHERE status = 'active'
ORDER BY created_at DESC
`

// List all active tenants (for admin/reporting)
func (q *Queries) ListActiveTenants(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listActiveTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Email,
			&i.Phone,
			&i.Website,
			&i.BusinessName,
			&i.TaxID,
			&i.Settings,
			&i.Status,
			&i.TrialEndsAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.GracePeriodStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTenantStatus = `-- name: SetTenantStatus :exec
UPDATE tenants
SET
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type SetTenantStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

// Update tenant status
func (q *Queries) SetTenantStatus(ctx context.Context, arg SetTenantStatusParams) error {
	_, err := q.db.Exec(ctx, setTenantStatus, arg.ID, arg.Status)
	return err
}

const startTenantGracePeriod = `-- name: StartTenantGracePeriod :exec
UPDATE tenants
SET
    status = 'past_due',
    grace_period_started_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

// Start grace period after payment failure
func (q *Queries) StartTenantGracePeriod(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, startTenantGracePeriod, id)
	return err
}

const suspendTenant = `-- name: SuspendTenant :exec
UPDATE tenants
SET
    status = 'suspended',
    updated_at = NOW()
WHERE id = $1
`

// Suspend a tenant (grace period expired or manual suspension)
func (q *Queries) SuspendTenant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, suspendTenant, id)
	return err
}

const tenantSlugExists = `-- name: TenantSlugExists :one
SELECT EXISTS(
    SELECT 1
    FROM tenants
    WHERE slug = $1
) as exists
`

// Check if a slug is already taken
func (q *Queries) TenantSlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, tenantSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTenantProfile = `-- name: UpdateTenantProfile :one
UPDATE tenants
SET
    name = COALESCE($2, name),
    email = COALESCE($3, email),
    phone = COALESCE($4, phone),
    website = COALESCE($5, website),
    business_name = COALESCE($6, business_name),
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, slug, email, phone, website, business_name, tax_id, settings, status, trial_ends_at, created_at, updated_at, stripe_customer_id, stripe_subscription_id, grace_period_started_at
`

type UpdateTenantProfileParams struct {
	ID           pgtype.UUID `json:"id"`
	Name         pgtype.Text `json:"name"`
	Email        pgtype.Text `json:"email"`
	Phone        pgtype.Text `json:"phone"`
	Website      pgtype.Text `json:"website"`
	BusinessName pgtype.Text `json:"business_name"`
}

// Update tenant profile information
func (q *Queries) UpdateTenantProfile(ctx context.Context, arg UpdateTenantProfileParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, updateTenantProfile,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Website,
		arg.BusinessName,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Email,
		&i.Phone,
		&i.Website,
		&i.BusinessName,
		&i.TaxID,
		&i.Settings,
		&i.Status,
		&i.TrialEndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.GracePeriodStartedAt,
	)
	return i, err
}

const updateTenantStripeCustomer = `-- name: UpdateTenantStripeCustomer :exec
UPDATE tenants
SET
    stripe_customer_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateTenantStripeCustomerParams struct {
	ID               pgtype.UUID `json:"id"`
	StripeCustomerID pgtype.Text `json:"stripe_customer_id"`
}

// Set Stripe customer ID for a tenant
func (q *Queries) UpdateTenantStripeCustomer(ctx context.Context, arg UpdateTenantStripeCustomerParams) error {
	_, err := q.db.Exec(ctx, updateTenantStripeCustomer, arg.ID, arg.StripeCustomerID)
	return err
}

const updateTenantStripeSubscription = `-- name: UpdateTenantStripeSubscription :exec
UPDATE tenants
SET
    stripe_subscription_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateTenantStripeSubscriptionParams struct {
	ID                   pgtype.UUID `json:"id"`
	StripeSubscriptionID pgtype.Text `json:"stripe_subscription_id"`
}

// Set Stripe subscription ID for a tenant
func (q *Queries) UpdateTenantStripeSubscription(ctx context.Context, arg UpdateTenantStripeSubscriptionParams) error {
	_, err := q.db.Exec(ctx, updateTenantStripeSubscription, arg.ID, arg.StripeSubscriptionID)
	return err
}
