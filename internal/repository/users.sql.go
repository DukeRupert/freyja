// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one

SELECT COUNT(*)
FROM users
WHERE tenant_id = $1
  AND status != 'closed'
`

// Admin queries
// Count total users for pagination
func (q *Queries) CountUsers(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    tenant_id,
    email,
    password_hash,
    first_name,
    last_name,
    account_type,
    status
) VALUES (
    $1, $2, $3, $4, $5, 'retail', 'active'
) RETURNING id, tenant_id, email, password_hash, email_verified, account_type, first_name, last_name, phone, company_name, tax_id, business_type, status, wholesale_application_status, wholesale_application_notes, wholesale_approved_at, wholesale_approved_by, payment_terms, metadata, created_at, updated_at
`

type CreateUserParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	Email        string      `json:"email"`
	PasswordHash pgtype.Text `json:"password_hash"`
	FirstName    pgtype.Text `json:"first_name"`
	LastName     pgtype.Text `json:"last_name"`
}

// Create a new user (retail account by default)
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.TenantID,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.AccountType,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.CompanyName,
		&i.TaxID,
		&i.BusinessType,
		&i.Status,
		&i.WholesaleApplicationStatus,
		&i.WholesaleApplicationNotes,
		&i.WholesaleApprovedAt,
		&i.WholesaleApprovedBy,
		&i.PaymentTerms,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, tenant_id, email, password_hash, email_verified, account_type, first_name, last_name, phone, company_name, tax_id, business_type, status, wholesale_application_status, wholesale_application_notes, wholesale_approved_at, wholesale_approved_by, payment_terms, metadata, created_at, updated_at
FROM users
WHERE tenant_id = $1
  AND email = $2
  AND status != 'closed'
LIMIT 1
`

type GetUserByEmailParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Email    string      `json:"email"`
}

// Get user by email within a tenant
func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.AccountType,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.CompanyName,
		&i.TaxID,
		&i.BusinessType,
		&i.Status,
		&i.WholesaleApplicationStatus,
		&i.WholesaleApplicationNotes,
		&i.WholesaleApprovedAt,
		&i.WholesaleApprovedBy,
		&i.PaymentTerms,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, tenant_id, email, password_hash, email_verified, account_type, first_name, last_name, phone, company_name, tax_id, business_type, status, wholesale_application_status, wholesale_application_notes, wholesale_approved_at, wholesale_approved_by, payment_terms, metadata, created_at, updated_at
FROM users
WHERE id = $1
  AND status != 'closed'
LIMIT 1
`

// Get user by ID
func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.AccountType,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.CompanyName,
		&i.TaxID,
		&i.BusinessType,
		&i.Status,
		&i.WholesaleApplicationStatus,
		&i.WholesaleApplicationNotes,
		&i.WholesaleApprovedAt,
		&i.WholesaleApprovedBy,
		&i.PaymentTerms,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT
    COUNT(*) as total_users,
    COUNT(*) FILTER (WHERE account_type = 'retail') as retail_users,
    COUNT(*) FILTER (WHERE account_type = 'wholesale') as wholesale_users,
    COUNT(*) FILTER (WHERE wholesale_application_status = 'pending') as pending_applications
FROM users
WHERE tenant_id = $1
  AND status != 'closed'
`

type GetUserStatsRow struct {
	TotalUsers          int64 `json:"total_users"`
	RetailUsers         int64 `json:"retail_users"`
	WholesaleUsers      int64 `json:"wholesale_users"`
	PendingApplications int64 `json:"pending_applications"`
}

// Get user statistics for dashboard
func (q *Queries) GetUserStats(ctx context.Context, tenantID pgtype.UUID) (GetUserStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserStats, tenantID)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.RetailUsers,
		&i.WholesaleUsers,
		&i.PendingApplications,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, tenant_id, email, password_hash, email_verified, account_type, first_name, last_name, phone, company_name, tax_id, business_type, status, wholesale_application_status, wholesale_application_notes, wholesale_approved_at, wholesale_approved_by, payment_terms, metadata, created_at, updated_at
FROM users
WHERE tenant_id = $1
  AND status != 'closed'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

// List all users for a tenant (admin only)
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.PasswordHash,
			&i.EmailVerified,
			&i.AccountType,
			&i.FirstName,
			&i.LastName,
			&i.Phone,
			&i.CompanyName,
			&i.TaxID,
			&i.BusinessType,
			&i.Status,
			&i.WholesaleApplicationStatus,
			&i.WholesaleApplicationNotes,
			&i.WholesaleApprovedAt,
			&i.WholesaleApprovedBy,
			&i.PaymentTerms,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByAccountType = `-- name: ListUsersByAccountType :many
SELECT id, tenant_id, email, password_hash, email_verified, account_type, first_name, last_name, phone, company_name, tax_id, business_type, status, wholesale_application_status, wholesale_application_notes, wholesale_approved_at, wholesale_approved_by, payment_terms, metadata, created_at, updated_at
FROM users
WHERE tenant_id = $1
  AND account_type = $2
  AND status != 'closed'
ORDER BY created_at DESC
`

type ListUsersByAccountTypeParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	AccountType string      `json:"account_type"`
}

// List users filtered by account type
func (q *Queries) ListUsersByAccountType(ctx context.Context, arg ListUsersByAccountTypeParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByAccountType, arg.TenantID, arg.AccountType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Email,
			&i.PasswordHash,
			&i.EmailVerified,
			&i.AccountType,
			&i.FirstName,
			&i.LastName,
			&i.Phone,
			&i.CompanyName,
			&i.TaxID,
			&i.BusinessType,
			&i.Status,
			&i.WholesaleApplicationStatus,
			&i.WholesaleApplicationNotes,
			&i.WholesaleApprovedAt,
			&i.WholesaleApprovedBy,
			&i.PaymentTerms,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWholesaleApplications = `-- name: ListWholesaleApplications :many
SELECT
    id,
    email,
    first_name,
    last_name,
    company_name,
    wholesale_application_status,
    wholesale_application_notes,
    created_at
FROM users
WHERE tenant_id = $1
  AND wholesale_application_status = 'pending'
ORDER BY created_at ASC
`

type ListWholesaleApplicationsRow struct {
	ID                         pgtype.UUID        `json:"id"`
	Email                      string             `json:"email"`
	FirstName                  pgtype.Text        `json:"first_name"`
	LastName                   pgtype.Text        `json:"last_name"`
	CompanyName                pgtype.Text        `json:"company_name"`
	WholesaleApplicationStatus pgtype.Text        `json:"wholesale_application_status"`
	WholesaleApplicationNotes  pgtype.Text        `json:"wholesale_application_notes"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
}

// List pending wholesale applications
func (q *Queries) ListWholesaleApplications(ctx context.Context, tenantID pgtype.UUID) ([]ListWholesaleApplicationsRow, error) {
	rows, err := q.db.Query(ctx, listWholesaleApplications, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWholesaleApplicationsRow{}
	for rows.Next() {
		var i ListWholesaleApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.CompanyName,
			&i.WholesaleApplicationStatus,
			&i.WholesaleApplicationNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

// Update user password
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users
SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    phone = COALESCE($4, phone)
WHERE id = $1
`

type UpdateUserProfileParams struct {
	ID        pgtype.UUID `json:"id"`
	FirstName pgtype.Text `json:"first_name"`
	LastName  pgtype.Text `json:"last_name"`
	Phone     pgtype.Text `json:"phone"`
}

// Update user profile information
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
	)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE users
SET status = $2
WHERE id = $1
`

type UpdateUserStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

// Update user status (active, suspended, closed)
func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserStatus, arg.ID, arg.Status)
	return err
}

const updateWholesaleApplication = `-- name: UpdateWholesaleApplication :exec
UPDATE users
SET
    wholesale_application_status = $2,
    wholesale_application_notes = $3,
    wholesale_approved_at = CASE WHEN $2 = 'approved' THEN NOW() ELSE NULL END,
    wholesale_approved_by = CASE WHEN $2 = 'approved' THEN $4 ELSE NULL END,
    account_type = CASE WHEN $2 = 'approved' THEN 'wholesale' ELSE account_type END,
    payment_terms = CASE WHEN $2 = 'approved' THEN COALESCE($5, 'net_30') ELSE payment_terms END
WHERE id = $1
`

type UpdateWholesaleApplicationParams struct {
	ID                         pgtype.UUID `json:"id"`
	WholesaleApplicationStatus pgtype.Text `json:"wholesale_application_status"`
	WholesaleApplicationNotes  pgtype.Text `json:"wholesale_application_notes"`
	WholesaleApprovedBy        pgtype.UUID `json:"wholesale_approved_by"`
	PaymentTerms               pgtype.Text `json:"payment_terms"`
}

// Update wholesale application status
func (q *Queries) UpdateWholesaleApplication(ctx context.Context, arg UpdateWholesaleApplicationParams) error {
	_, err := q.db.Exec(ctx, updateWholesaleApplication,
		arg.ID,
		arg.WholesaleApplicationStatus,
		arg.WholesaleApplicationNotes,
		arg.WholesaleApprovedBy,
		arg.PaymentTerms,
	)
	return err
}

const verifyUserEmail = `-- name: VerifyUserEmail :exec
UPDATE users
SET email_verified = TRUE
WHERE id = $1
`

// Mark user email as verified
func (q *Queries) VerifyUserEmail(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, verifyUserEmail, id)
	return err
}
