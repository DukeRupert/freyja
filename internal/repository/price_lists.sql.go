// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: price_lists.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDefaultPriceList = `-- name: GetDefaultPriceList :one
SELECT
    id,
    tenant_id,
    name,
    description,
    list_type,
    is_active,
    created_at,
    updated_at
FROM price_lists
WHERE tenant_id = $1
  AND list_type = 'default'
  AND is_active = TRUE
LIMIT 1
`

// Get the default price list for a tenant (used for guests and unassigned users)
func (q *Queries) GetDefaultPriceList(ctx context.Context, tenantID pgtype.UUID) (PriceList, error) {
	row := q.db.QueryRow(ctx, getDefaultPriceList, tenantID)
	var i PriceList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.ListType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPriceForSKU = `-- name: GetPriceForSKU :one
SELECT
    id,
    tenant_id,
    price_list_id,
    product_sku_id,
    price_cents,
    compare_at_price_cents,
    is_available,
    created_at,
    updated_at
FROM price_list_entries
WHERE price_list_id = $1
  AND product_sku_id = $2
  AND is_available = TRUE
LIMIT 1
`

type GetPriceForSKUParams struct {
	PriceListID  pgtype.UUID `json:"price_list_id"`
	ProductSkuID pgtype.UUID `json:"product_sku_id"`
}

// Get the price for a specific SKU on a price list
func (q *Queries) GetPriceForSKU(ctx context.Context, arg GetPriceForSKUParams) (PriceListEntry, error) {
	row := q.db.QueryRow(ctx, getPriceForSKU, arg.PriceListID, arg.ProductSkuID)
	var i PriceListEntry
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.PriceListID,
		&i.ProductSkuID,
		&i.PriceCents,
		&i.CompareAtPriceCents,
		&i.IsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPriceListByID = `-- name: GetPriceListByID :one
SELECT
    id,
    tenant_id,
    name,
    description,
    list_type,
    is_active,
    created_at,
    updated_at
FROM price_lists
WHERE id = $1
  AND is_active = TRUE
LIMIT 1
`

// Get a price list by ID
func (q *Queries) GetPriceListByID(ctx context.Context, id pgtype.UUID) (PriceList, error) {
	row := q.db.QueryRow(ctx, getPriceListByID, id)
	var i PriceList
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.ListType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPricesForProduct = `-- name: GetPricesForProduct :many
SELECT
    ple.id,
    ple.product_sku_id,
    ple.price_cents,
    ple.compare_at_price_cents,
    ple.is_available,
    ps.sku,
    ps.weight_value,
    ps.weight_unit,
    ps.grind,
    ps.inventory_quantity,
    ps.is_active
FROM price_list_entries ple
INNER JOIN product_skus ps ON ps.id = ple.product_sku_id
WHERE ple.price_list_id = $1
  AND ps.product_id = $2
  AND ple.is_available = TRUE
  AND ps.is_active = TRUE
ORDER BY ps.weight_value ASC, ps.grind ASC
`

type GetPricesForProductParams struct {
	PriceListID pgtype.UUID `json:"price_list_id"`
	ProductID   pgtype.UUID `json:"product_id"`
}

type GetPricesForProductRow struct {
	ID                  pgtype.UUID    `json:"id"`
	ProductSkuID        pgtype.UUID    `json:"product_sku_id"`
	PriceCents          int32          `json:"price_cents"`
	CompareAtPriceCents pgtype.Int4    `json:"compare_at_price_cents"`
	IsAvailable         bool           `json:"is_available"`
	Sku                 string         `json:"sku"`
	WeightValue         pgtype.Numeric `json:"weight_value"`
	WeightUnit          string         `json:"weight_unit"`
	Grind               string         `json:"grind"`
	InventoryQuantity   int32          `json:"inventory_quantity"`
	IsActive            bool           `json:"is_active"`
}

// Get all SKU prices for a product on a specific price list
func (q *Queries) GetPricesForProduct(ctx context.Context, arg GetPricesForProductParams) ([]GetPricesForProductRow, error) {
	rows, err := q.db.Query(ctx, getPricesForProduct, arg.PriceListID, arg.ProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPricesForProductRow{}
	for rows.Next() {
		var i GetPricesForProductRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductSkuID,
			&i.PriceCents,
			&i.CompareAtPriceCents,
			&i.IsAvailable,
			&i.Sku,
			&i.WeightValue,
			&i.WeightUnit,
			&i.Grind,
			&i.InventoryQuantity,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricesForSKUs = `-- name: GetPricesForSKUs :many
SELECT
    product_sku_id,
    price_cents,
    compare_at_price_cents
FROM price_list_entries
WHERE price_list_id = $1
  AND product_sku_id = ANY($2::uuid[])
  AND is_available = TRUE
`

type GetPricesForSKUsParams struct {
	PriceListID pgtype.UUID   `json:"price_list_id"`
	Column2     []pgtype.UUID `json:"column_2"`
}

type GetPricesForSKUsRow struct {
	ProductSkuID        pgtype.UUID `json:"product_sku_id"`
	PriceCents          int32       `json:"price_cents"`
	CompareAtPriceCents pgtype.Int4 `json:"compare_at_price_cents"`
}

// Batch fetch prices for multiple SKUs on a price list
func (q *Queries) GetPricesForSKUs(ctx context.Context, arg GetPricesForSKUsParams) ([]GetPricesForSKUsRow, error) {
	rows, err := q.db.Query(ctx, getPricesForSKUs, arg.PriceListID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPricesForSKUsRow{}
	for rows.Next() {
		var i GetPricesForSKUsRow
		if err := rows.Scan(&i.ProductSkuID, &i.PriceCents, &i.CompareAtPriceCents); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
