// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*)
FROM orders
WHERE tenant_id = $1
`

// Count total orders for pagination
func (q *Queries) CountOrders(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    tenant_id,
    cart_id,
    user_id,
    order_number,
    order_type,
    status,
    subtotal_cents,
    shipping_cents,
    tax_cents,
    total_cents,
    currency,
    shipping_address_id,
    billing_address_id,
    customer_notes,
    subscription_id,
    customer_po_number,
    requested_delivery_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, tenant_id, user_id, order_number, order_type, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, currency, payment_id, payment_status, shipping_address_id, billing_address_id, shipping_method, shipping_carrier, customer_notes, internal_notes, fulfillment_status, cart_id, subscription_id, metadata, paid_at, shipped_at, delivered_at, cancelled_at, created_at, updated_at, customer_po_number, requested_delivery_date
`

type CreateOrderParams struct {
	TenantID              pgtype.UUID `json:"tenant_id"`
	CartID                pgtype.UUID `json:"cart_id"`
	UserID                pgtype.UUID `json:"user_id"`
	OrderNumber           string      `json:"order_number"`
	OrderType             string      `json:"order_type"`
	Status                string      `json:"status"`
	SubtotalCents         int32       `json:"subtotal_cents"`
	ShippingCents         int32       `json:"shipping_cents"`
	TaxCents              int32       `json:"tax_cents"`
	TotalCents            int32       `json:"total_cents"`
	Currency              string      `json:"currency"`
	ShippingAddressID     pgtype.UUID `json:"shipping_address_id"`
	BillingAddressID      pgtype.UUID `json:"billing_address_id"`
	CustomerNotes         pgtype.Text `json:"customer_notes"`
	SubscriptionID        pgtype.UUID `json:"subscription_id"`
	CustomerPoNumber      pgtype.Text `json:"customer_po_number"`
	RequestedDeliveryDate pgtype.Date `json:"requested_delivery_date"`
}

// Creates a new order record with all required fields
// Returns the complete order with generated ID and timestamps
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.TenantID,
		arg.CartID,
		arg.UserID,
		arg.OrderNumber,
		arg.OrderType,
		arg.Status,
		arg.SubtotalCents,
		arg.ShippingCents,
		arg.TaxCents,
		arg.TotalCents,
		arg.Currency,
		arg.ShippingAddressID,
		arg.BillingAddressID,
		arg.CustomerNotes,
		arg.SubscriptionID,
		arg.CustomerPoNumber,
		arg.RequestedDeliveryDate,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerPoNumber,
		&i.RequestedDeliveryDate,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    tenant_id,
    order_id,
    product_sku_id,
    product_name,
    sku,
    variant_description,
    quantity,
    unit_price_cents,
    total_price_cents
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, tenant_id, order_id, product_sku_id, product_name, sku, variant_description, quantity, unit_price_cents, total_price_cents, fulfillment_status, metadata, created_at, updated_at, quantity_dispatched
`

type CreateOrderItemParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	OrderID            pgtype.UUID `json:"order_id"`
	ProductSkuID       pgtype.UUID `json:"product_sku_id"`
	ProductName        string      `json:"product_name"`
	Sku                string      `json:"sku"`
	VariantDescription pgtype.Text `json:"variant_description"`
	Quantity           int32       `json:"quantity"`
	UnitPriceCents     int32       `json:"unit_price_cents"`
	TotalPriceCents    int32       `json:"total_price_cents"`
}

// Creates an order line item linked to a specific order
// Captures product state at time of purchase
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.TenantID,
		arg.OrderID,
		arg.ProductSkuID,
		arg.ProductName,
		arg.Sku,
		arg.VariantDescription,
		arg.Quantity,
		arg.UnitPriceCents,
		arg.TotalPriceCents,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.ProductSkuID,
		&i.ProductName,
		&i.Sku,
		&i.VariantDescription,
		&i.Quantity,
		&i.UnitPriceCents,
		&i.TotalPriceCents,
		&i.FulfillmentStatus,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.QuantityDispatched,
	)
	return i, err
}

const createShipment = `-- name: CreateShipment :one
INSERT INTO shipments (
    tenant_id,
    order_id,
    carrier,
    tracking_number,
    shipping_method_id,
    status
) VALUES (
    $1, $2, $3, $4, $5, 'pending'
)
RETURNING id, tenant_id, order_id, shipment_number, shipping_method_id, carrier, service_name, tracking_number, tracking_url, status, shipping_cost_cents, label_cost_cents, weight_grams, length_cm, width_cm, height_cm, provider, provider_shipment_id, provider_label_id, label_url, metadata, label_created_at, shipped_at, delivered_at, failed_at, created_at, updated_at
`

type CreateShipmentParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	OrderID          pgtype.UUID `json:"order_id"`
	Carrier          pgtype.Text `json:"carrier"`
	TrackingNumber   pgtype.Text `json:"tracking_number"`
	ShippingMethodID pgtype.UUID `json:"shipping_method_id"`
}

// Create a shipment record for an order
func (q *Queries) CreateShipment(ctx context.Context, arg CreateShipmentParams) (Shipment, error) {
	row := q.db.QueryRow(ctx, createShipment,
		arg.TenantID,
		arg.OrderID,
		arg.Carrier,
		arg.TrackingNumber,
		arg.ShippingMethodID,
	)
	var i Shipment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.ShipmentNumber,
		&i.ShippingMethodID,
		&i.Carrier,
		&i.ServiceName,
		&i.TrackingNumber,
		&i.TrackingUrl,
		&i.Status,
		&i.ShippingCostCents,
		&i.LabelCostCents,
		&i.WeightGrams,
		&i.LengthCm,
		&i.WidthCm,
		&i.HeightCm,
		&i.Provider,
		&i.ProviderShipmentID,
		&i.ProviderLabelID,
		&i.LabelUrl,
		&i.Metadata,
		&i.LabelCreatedAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShipmentItem = `-- name: CreateShipmentItem :one

INSERT INTO shipment_items (
    tenant_id,
    shipment_id,
    order_item_id,
    quantity
) VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, shipment_id, order_item_id, quantity, created_at
`

type CreateShipmentItemParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	ShipmentID  pgtype.UUID `json:"shipment_id"`
	OrderItemID pgtype.UUID `json:"order_item_id"`
	Quantity    int32       `json:"quantity"`
}

// =============================================================================
// SHIPMENT ITEM QUERIES
// =============================================================================
// Create a shipment line item for partial fulfillment
func (q *Queries) CreateShipmentItem(ctx context.Context, arg CreateShipmentItemParams) (ShipmentItem, error) {
	row := q.db.QueryRow(ctx, createShipmentItem,
		arg.TenantID,
		arg.ShipmentID,
		arg.OrderItemID,
		arg.Quantity,
	)
	var i ShipmentItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ShipmentID,
		&i.OrderItemID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const decrementSKUStock = `-- name: DecrementSKUStock :exec
UPDATE product_skus
SET inventory_quantity = inventory_quantity - $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
  AND inventory_quantity >= $3
`

type DecrementSKUStockParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	ID                pgtype.UUID `json:"id"`
	InventoryQuantity int32       `json:"inventory_quantity"`
}

// Decrements inventory for a SKU after order placement
// Uses optimistic locking to prevent overselling
func (q *Queries) DecrementSKUStock(ctx context.Context, arg DecrementSKUStockParams) error {
	_, err := q.db.Exec(ctx, decrementSKUStock, arg.TenantID, arg.ID, arg.InventoryQuantity)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT id, tenant_id, user_id, order_number, order_type, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, currency, payment_id, payment_status, shipping_address_id, billing_address_id, shipping_method, shipping_carrier, customer_notes, internal_notes, fulfillment_status, cart_id, subscription_id, metadata, paid_at, shipped_at, delivered_at, cancelled_at, created_at, updated_at, customer_po_number, requested_delivery_date FROM orders
WHERE tenant_id = $1
  AND id = $2
LIMIT 1
`

type GetOrderParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Retrieves a single order by ID with tenant scoping
func (q *Queries) GetOrder(ctx context.Context, arg GetOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, arg.TenantID, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerPoNumber,
		&i.RequestedDeliveryDate,
	)
	return i, err
}

const getOrderByNumber = `-- name: GetOrderByNumber :one
SELECT id, tenant_id, user_id, order_number, order_type, status, subtotal_cents, tax_cents, shipping_cents, discount_cents, total_cents, currency, payment_id, payment_status, shipping_address_id, billing_address_id, shipping_method, shipping_carrier, customer_notes, internal_notes, fulfillment_status, cart_id, subscription_id, metadata, paid_at, shipped_at, delivered_at, cancelled_at, created_at, updated_at, customer_po_number, requested_delivery_date FROM orders
WHERE tenant_id = $1
  AND order_number = $2
LIMIT 1
`

type GetOrderByNumberParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	OrderNumber string      `json:"order_number"`
}

// Retrieves a single order by order number with tenant scoping
// Order numbers are unique per tenant
func (q *Queries) GetOrderByNumber(ctx context.Context, arg GetOrderByNumberParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByNumber, arg.TenantID, arg.OrderNumber)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerPoNumber,
		&i.RequestedDeliveryDate,
	)
	return i, err
}

const getOrderByPaymentIntentID = `-- name: GetOrderByPaymentIntentID :one
SELECT o.id, o.tenant_id, o.user_id, o.order_number, o.order_type, o.status, o.subtotal_cents, o.tax_cents, o.shipping_cents, o.discount_cents, o.total_cents, o.currency, o.payment_id, o.payment_status, o.shipping_address_id, o.billing_address_id, o.shipping_method, o.shipping_carrier, o.customer_notes, o.internal_notes, o.fulfillment_status, o.cart_id, o.subscription_id, o.metadata, o.paid_at, o.shipped_at, o.delivered_at, o.cancelled_at, o.created_at, o.updated_at, o.customer_po_number, o.requested_delivery_date FROM orders o
INNER JOIN payments p ON p.id = o.payment_id AND p.tenant_id = o.tenant_id
WHERE o.tenant_id = $1
  AND p.provider_payment_id = $2
LIMIT 1
`

type GetOrderByPaymentIntentIDParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	ProviderPaymentID string      `json:"provider_payment_id"`
}

// Idempotency check: Returns existing order if payment intent was already processed
// This prevents duplicate order creation from webhook retries
func (q *Queries) GetOrderByPaymentIntentID(ctx context.Context, arg GetOrderByPaymentIntentIDParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByPaymentIntentID, arg.TenantID, arg.ProviderPaymentID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerPoNumber,
		&i.RequestedDeliveryDate,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT id, tenant_id, order_id, product_sku_id, product_name, sku, variant_description, quantity, unit_price_cents, total_price_cents, fulfillment_status, metadata, created_at, updated_at, quantity_dispatched FROM order_items
WHERE order_id = $1
ORDER BY created_at ASC
`

// Retrieves all line items for a specific order
func (q *Queries) GetOrderItems(ctx context.Context, orderID pgtype.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderID,
			&i.ProductSkuID,
			&i.ProductName,
			&i.Sku,
			&i.VariantDescription,
			&i.Quantity,
			&i.UnitPriceCents,
			&i.TotalPriceCents,
			&i.FulfillmentStatus,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuantityDispatched,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsWithFulfillment = `-- name: GetOrderItemsWithFulfillment :many
SELECT
    oi.id,
    oi.order_id,
    oi.product_sku_id,
    oi.product_name,
    oi.sku,
    oi.variant_description,
    oi.quantity,
    oi.quantity_dispatched,
    oi.unit_price_cents,
    oi.total_price_cents,
    oi.fulfillment_status,
    (oi.quantity - oi.quantity_dispatched) as quantity_remaining
FROM order_items oi
WHERE oi.order_id = $1
ORDER BY oi.created_at ASC
`

type GetOrderItemsWithFulfillmentRow struct {
	ID                 pgtype.UUID `json:"id"`
	OrderID            pgtype.UUID `json:"order_id"`
	ProductSkuID       pgtype.UUID `json:"product_sku_id"`
	ProductName        string      `json:"product_name"`
	Sku                string      `json:"sku"`
	VariantDescription pgtype.Text `json:"variant_description"`
	Quantity           int32       `json:"quantity"`
	QuantityDispatched int32       `json:"quantity_dispatched"`
	UnitPriceCents     int32       `json:"unit_price_cents"`
	TotalPriceCents    int32       `json:"total_price_cents"`
	FulfillmentStatus  string      `json:"fulfillment_status"`
	QuantityRemaining  int32       `json:"quantity_remaining"`
}

// Get order items with fulfillment status for partial shipment display
func (q *Queries) GetOrderItemsWithFulfillment(ctx context.Context, orderID pgtype.UUID) ([]GetOrderItemsWithFulfillmentRow, error) {
	rows, err := q.db.Query(ctx, getOrderItemsWithFulfillment, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsWithFulfillmentRow{}
	for rows.Next() {
		var i GetOrderItemsWithFulfillmentRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductSkuID,
			&i.ProductName,
			&i.Sku,
			&i.VariantDescription,
			&i.Quantity,
			&i.QuantityDispatched,
			&i.UnitPriceCents,
			&i.TotalPriceCents,
			&i.FulfillmentStatus,
			&i.QuantityRemaining,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderStats = `-- name: GetOrderStats :one
SELECT
    COUNT(*) as total_orders,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_orders,
    COUNT(*) FILTER (WHERE status = 'processing') as processing_orders,
    COUNT(*) FILTER (WHERE status = 'shipped') as shipped_orders,
    COALESCE(SUM(total_cents), 0) as total_revenue_cents
FROM orders
WHERE tenant_id = $1
  AND created_at >= $2
`

type GetOrderStatsParams struct {
	TenantID  pgtype.UUID        `json:"tenant_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type GetOrderStatsRow struct {
	TotalOrders       int64       `json:"total_orders"`
	PendingOrders     int64       `json:"pending_orders"`
	ProcessingOrders  int64       `json:"processing_orders"`
	ShippedOrders     int64       `json:"shipped_orders"`
	TotalRevenueCents interface{} `json:"total_revenue_cents"`
}

// Get order statistics for dashboard
func (q *Queries) GetOrderStats(ctx context.Context, arg GetOrderStatsParams) (GetOrderStatsRow, error) {
	row := q.db.QueryRow(ctx, getOrderStats, arg.TenantID, arg.CreatedAt)
	var i GetOrderStatsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.PendingOrders,
		&i.ProcessingOrders,
		&i.ShippedOrders,
		&i.TotalRevenueCents,
	)
	return i, err
}

const getOrderWithDetails = `-- name: GetOrderWithDetails :one
SELECT
    o.id,
    o.tenant_id,
    o.order_number,
    o.order_type,
    o.status,
    o.fulfillment_status,
    o.subtotal_cents,
    o.shipping_cents,
    o.tax_cents,
    o.total_cents,
    o.currency,
    o.customer_notes,
    o.created_at,
    o.updated_at,
    u.email as customer_email,
    u.first_name as customer_first_name,
    u.last_name as customer_last_name,
    sa.full_name as shipping_name,
    sa.company as shipping_company,
    sa.address_line1 as shipping_address_line1,
    sa.address_line2 as shipping_address_line2,
    sa.city as shipping_city,
    sa.state as shipping_state,
    sa.postal_code as shipping_postal_code,
    sa.country as shipping_country,
    sa.phone as shipping_phone,
    ba.full_name as billing_name,
    ba.address_line1 as billing_address_line1,
    ba.address_line2 as billing_address_line2,
    ba.city as billing_city,
    ba.state as billing_state,
    ba.postal_code as billing_postal_code,
    ba.country as billing_country,
    p.status as payment_status,
    p.provider_payment_id
FROM orders o
LEFT JOIN users u ON u.id = o.user_id
LEFT JOIN addresses sa ON sa.id = o.shipping_address_id
LEFT JOIN addresses ba ON ba.id = o.billing_address_id
LEFT JOIN payments p ON p.id = o.payment_id
WHERE o.tenant_id = $1
  AND o.id = $2
LIMIT 1
`

type GetOrderWithDetailsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

type GetOrderWithDetailsRow struct {
	ID                   pgtype.UUID        `json:"id"`
	TenantID             pgtype.UUID        `json:"tenant_id"`
	OrderNumber          string             `json:"order_number"`
	OrderType            string             `json:"order_type"`
	Status               string             `json:"status"`
	FulfillmentStatus    string             `json:"fulfillment_status"`
	SubtotalCents        int32              `json:"subtotal_cents"`
	ShippingCents        int32              `json:"shipping_cents"`
	TaxCents             int32              `json:"tax_cents"`
	TotalCents           int32              `json:"total_cents"`
	Currency             string             `json:"currency"`
	CustomerNotes        pgtype.Text        `json:"customer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CustomerEmail        pgtype.Text        `json:"customer_email"`
	CustomerFirstName    pgtype.Text        `json:"customer_first_name"`
	CustomerLastName     pgtype.Text        `json:"customer_last_name"`
	ShippingName         pgtype.Text        `json:"shipping_name"`
	ShippingCompany      pgtype.Text        `json:"shipping_company"`
	ShippingAddressLine1 pgtype.Text        `json:"shipping_address_line1"`
	ShippingAddressLine2 pgtype.Text        `json:"shipping_address_line2"`
	ShippingCity         pgtype.Text        `json:"shipping_city"`
	ShippingState        pgtype.Text        `json:"shipping_state"`
	ShippingPostalCode   pgtype.Text        `json:"shipping_postal_code"`
	ShippingCountry      pgtype.Text        `json:"shipping_country"`
	ShippingPhone        pgtype.Text        `json:"shipping_phone"`
	BillingName          pgtype.Text        `json:"billing_name"`
	BillingAddressLine1  pgtype.Text        `json:"billing_address_line1"`
	BillingAddressLine2  pgtype.Text        `json:"billing_address_line2"`
	BillingCity          pgtype.Text        `json:"billing_city"`
	BillingState         pgtype.Text        `json:"billing_state"`
	BillingPostalCode    pgtype.Text        `json:"billing_postal_code"`
	BillingCountry       pgtype.Text        `json:"billing_country"`
	PaymentStatus        pgtype.Text        `json:"payment_status"`
	ProviderPaymentID    pgtype.Text        `json:"provider_payment_id"`
}

// Get complete order details including addresses and payment info
func (q *Queries) GetOrderWithDetails(ctx context.Context, arg GetOrderWithDetailsParams) (GetOrderWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithDetails, arg.TenantID, arg.ID)
	var i GetOrderWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.FulfillmentStatus,
		&i.SubtotalCents,
		&i.ShippingCents,
		&i.TaxCents,
		&i.TotalCents,
		&i.Currency,
		&i.CustomerNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerEmail,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.ShippingName,
		&i.ShippingCompany,
		&i.ShippingAddressLine1,
		&i.ShippingAddressLine2,
		&i.ShippingCity,
		&i.ShippingState,
		&i.ShippingPostalCode,
		&i.ShippingCountry,
		&i.ShippingPhone,
		&i.BillingName,
		&i.BillingAddressLine1,
		&i.BillingAddressLine2,
		&i.BillingCity,
		&i.BillingState,
		&i.BillingPostalCode,
		&i.BillingCountry,
		&i.PaymentStatus,
		&i.ProviderPaymentID,
	)
	return i, err
}

const getOrderWithWholesaleDetails = `-- name: GetOrderWithWholesaleDetails :one
SELECT
    o.id, o.tenant_id, o.user_id, o.order_number, o.order_type, o.status, o.subtotal_cents, o.tax_cents, o.shipping_cents, o.discount_cents, o.total_cents, o.currency, o.payment_id, o.payment_status, o.shipping_address_id, o.billing_address_id, o.shipping_method, o.shipping_carrier, o.customer_notes, o.internal_notes, o.fulfillment_status, o.cart_id, o.subscription_id, o.metadata, o.paid_at, o.shipped_at, o.delivered_at, o.cancelled_at, o.created_at, o.updated_at, o.customer_po_number, o.requested_delivery_date,
    u.email as customer_email,
    u.first_name as customer_first_name,
    u.last_name as customer_last_name,
    u.company_name,
    u.payment_terms_id,
    pt.name as payment_terms_name,
    pt.days as payment_terms_days
FROM orders o
JOIN users u ON u.id = o.user_id
LEFT JOIN payment_terms pt ON pt.id = u.payment_terms_id
WHERE o.tenant_id = $1
  AND o.id = $2
LIMIT 1
`

type GetOrderWithWholesaleDetailsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

type GetOrderWithWholesaleDetailsRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	UserID                pgtype.UUID        `json:"user_id"`
	OrderNumber           string             `json:"order_number"`
	OrderType             string             `json:"order_type"`
	Status                string             `json:"status"`
	SubtotalCents         int32              `json:"subtotal_cents"`
	TaxCents              int32              `json:"tax_cents"`
	ShippingCents         int32              `json:"shipping_cents"`
	DiscountCents         int32              `json:"discount_cents"`
	TotalCents            int32              `json:"total_cents"`
	Currency              string             `json:"currency"`
	PaymentID             pgtype.UUID        `json:"payment_id"`
	PaymentStatus         string             `json:"payment_status"`
	ShippingAddressID     pgtype.UUID        `json:"shipping_address_id"`
	BillingAddressID      pgtype.UUID        `json:"billing_address_id"`
	ShippingMethod        pgtype.Text        `json:"shipping_method"`
	ShippingCarrier       pgtype.Text        `json:"shipping_carrier"`
	CustomerNotes         pgtype.Text        `json:"customer_notes"`
	InternalNotes         pgtype.Text        `json:"internal_notes"`
	FulfillmentStatus     string             `json:"fulfillment_status"`
	CartID                pgtype.UUID        `json:"cart_id"`
	SubscriptionID        pgtype.UUID        `json:"subscription_id"`
	Metadata              []byte             `json:"metadata"`
	PaidAt                pgtype.Timestamptz `json:"paid_at"`
	ShippedAt             pgtype.Timestamptz `json:"shipped_at"`
	DeliveredAt           pgtype.Timestamptz `json:"delivered_at"`
	CancelledAt           pgtype.Timestamptz `json:"cancelled_at"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	CustomerPoNumber      pgtype.Text        `json:"customer_po_number"`
	RequestedDeliveryDate pgtype.Date        `json:"requested_delivery_date"`
	CustomerEmail         string             `json:"customer_email"`
	CustomerFirstName     pgtype.Text        `json:"customer_first_name"`
	CustomerLastName      pgtype.Text        `json:"customer_last_name"`
	CompanyName           pgtype.Text        `json:"company_name"`
	PaymentTermsID        pgtype.UUID        `json:"payment_terms_id"`
	PaymentTermsName      pgtype.Text        `json:"payment_terms_name"`
	PaymentTermsDays      pgtype.Int4        `json:"payment_terms_days"`
}

// Get order with wholesale-specific fields
func (q *Queries) GetOrderWithWholesaleDetails(ctx context.Context, arg GetOrderWithWholesaleDetailsParams) (GetOrderWithWholesaleDetailsRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithWholesaleDetails, arg.TenantID, arg.ID)
	var i GetOrderWithWholesaleDetailsRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.OrderNumber,
		&i.OrderType,
		&i.Status,
		&i.SubtotalCents,
		&i.TaxCents,
		&i.ShippingCents,
		&i.DiscountCents,
		&i.TotalCents,
		&i.Currency,
		&i.PaymentID,
		&i.PaymentStatus,
		&i.ShippingAddressID,
		&i.BillingAddressID,
		&i.ShippingMethod,
		&i.ShippingCarrier,
		&i.CustomerNotes,
		&i.InternalNotes,
		&i.FulfillmentStatus,
		&i.CartID,
		&i.SubscriptionID,
		&i.Metadata,
		&i.PaidAt,
		&i.ShippedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerPoNumber,
		&i.RequestedDeliveryDate,
		&i.CustomerEmail,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.CompanyName,
		&i.PaymentTermsID,
		&i.PaymentTermsName,
		&i.PaymentTermsDays,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, tenant_id, billing_customer_id, provider, provider_payment_id, amount_cents, currency, status, payment_method_id, failure_code, failure_message, refunded_amount_cents, metadata, succeeded_at, failed_at, refunded_at, created_at, updated_at FROM payments
WHERE id = $1
LIMIT 1
`

// Retrieves a single payment by ID
func (q *Queries) GetPaymentByID(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.BillingCustomerID,
		&i.Provider,
		&i.ProviderPaymentID,
		&i.AmountCents,
		&i.Currency,
		&i.Status,
		&i.PaymentMethodID,
		&i.FailureCode,
		&i.FailureMessage,
		&i.RefundedAmountCents,
		&i.Metadata,
		&i.SucceededAt,
		&i.FailedAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShipmentHistory = `-- name: GetShipmentHistory :many
SELECT
    s.id as shipment_id,
    s.shipment_number,
    s.carrier,
    s.tracking_number,
    s.status,
    s.shipped_at,
    si.quantity
FROM shipment_items si
JOIN shipments s ON s.id = si.shipment_id
WHERE si.order_item_id = $1
ORDER BY s.created_at DESC
`

type GetShipmentHistoryRow struct {
	ShipmentID     pgtype.UUID        `json:"shipment_id"`
	ShipmentNumber string             `json:"shipment_number"`
	Carrier        pgtype.Text        `json:"carrier"`
	TrackingNumber pgtype.Text        `json:"tracking_number"`
	Status         string             `json:"status"`
	ShippedAt      pgtype.Timestamptz `json:"shipped_at"`
	Quantity       int32              `json:"quantity"`
}

// Get shipment history for an order item
func (q *Queries) GetShipmentHistory(ctx context.Context, orderItemID pgtype.UUID) ([]GetShipmentHistoryRow, error) {
	rows, err := q.db.Query(ctx, getShipmentHistory, orderItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShipmentHistoryRow{}
	for rows.Next() {
		var i GetShipmentHistoryRow
		if err := rows.Scan(
			&i.ShipmentID,
			&i.ShipmentNumber,
			&i.Carrier,
			&i.TrackingNumber,
			&i.Status,
			&i.ShippedAt,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentItems = `-- name: GetShipmentItems :many
SELECT
    si.id,
    si.shipment_id,
    si.order_item_id,
    si.quantity,
    oi.product_name,
    oi.sku,
    oi.variant_description
FROM shipment_items si
JOIN order_items oi ON oi.id = si.order_item_id
WHERE si.shipment_id = $1
ORDER BY oi.created_at ASC
`

type GetShipmentItemsRow struct {
	ID                 pgtype.UUID `json:"id"`
	ShipmentID         pgtype.UUID `json:"shipment_id"`
	OrderItemID        pgtype.UUID `json:"order_item_id"`
	Quantity           int32       `json:"quantity"`
	ProductName        string      `json:"product_name"`
	Sku                string      `json:"sku"`
	VariantDescription pgtype.Text `json:"variant_description"`
}

// Get items in a shipment
func (q *Queries) GetShipmentItems(ctx context.Context, shipmentID pgtype.UUID) ([]GetShipmentItemsRow, error) {
	rows, err := q.db.Query(ctx, getShipmentItems, shipmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShipmentItemsRow{}
	for rows.Next() {
		var i GetShipmentItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ShipmentID,
			&i.OrderItemID,
			&i.Quantity,
			&i.ProductName,
			&i.Sku,
			&i.VariantDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShipmentsByOrderID = `-- name: GetShipmentsByOrderID :many
SELECT id, tenant_id, order_id, shipment_number, shipping_method_id, carrier, service_name, tracking_number, tracking_url, status, shipping_cost_cents, label_cost_cents, weight_grams, length_cm, width_cm, height_cm, provider, provider_shipment_id, provider_label_id, label_url, metadata, label_created_at, shipped_at, delivered_at, failed_at, created_at, updated_at FROM shipments
WHERE order_id = $1
ORDER BY created_at DESC
`

// Get all shipments for an order
func (q *Queries) GetShipmentsByOrderID(ctx context.Context, orderID pgtype.UUID) ([]Shipment, error) {
	rows, err := q.db.Query(ctx, getShipmentsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Shipment{}
	for rows.Next() {
		var i Shipment
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderID,
			&i.ShipmentNumber,
			&i.ShippingMethodID,
			&i.Carrier,
			&i.ServiceName,
			&i.TrackingNumber,
			&i.TrackingUrl,
			&i.Status,
			&i.ShippingCostCents,
			&i.LabelCostCents,
			&i.WeightGrams,
			&i.LengthCm,
			&i.WidthCm,
			&i.HeightCm,
			&i.Provider,
			&i.ProviderShipmentID,
			&i.ProviderLabelID,
			&i.LabelUrl,
			&i.Metadata,
			&i.LabelCreatedAt,
			&i.ShippedAt,
			&i.DeliveredAt,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantWarehouseAddress = `-- name: GetTenantWarehouseAddress :one

SELECT
    id,
    tenant_id,
    address_type,
    full_name,
    company,
    address_line1,
    address_line2,
    city,
    state,
    postal_code,
    country,
    phone
FROM addresses
WHERE tenant_id = $1
  AND address_type = 'warehouse'
LIMIT 1
`

type GetTenantWarehouseAddressRow struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	AddressType  string      `json:"address_type"`
	FullName     pgtype.Text `json:"full_name"`
	Company      pgtype.Text `json:"company"`
	AddressLine1 string      `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
	City         string      `json:"city"`
	State        string      `json:"state"`
	PostalCode   string      `json:"postal_code"`
	Country      string      `json:"country"`
	Phone        pgtype.Text `json:"phone"`
}

// Checkout queries
// Get the primary warehouse address for a tenant (for shipping origin calculations)
// Used by CheckoutService.GetShippingRates to determine shipping origin
func (q *Queries) GetTenantWarehouseAddress(ctx context.Context, tenantID pgtype.UUID) (GetTenantWarehouseAddressRow, error) {
	row := q.db.QueryRow(ctx, getTenantWarehouseAddress, tenantID)
	var i GetTenantWarehouseAddressRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AddressType,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
	)
	return i, err
}

const getUnfulfilledOrderItems = `-- name: GetUnfulfilledOrderItems :many
SELECT
    oi.id,
    oi.order_id,
    oi.product_sku_id,
    oi.product_name,
    oi.sku,
    oi.variant_description,
    oi.quantity,
    oi.quantity_dispatched,
    (oi.quantity - oi.quantity_dispatched) as quantity_remaining
FROM order_items oi
WHERE oi.order_id = $1
  AND oi.quantity_dispatched < oi.quantity
ORDER BY oi.created_at ASC
`

type GetUnfulfilledOrderItemsRow struct {
	ID                 pgtype.UUID `json:"id"`
	OrderID            pgtype.UUID `json:"order_id"`
	ProductSkuID       pgtype.UUID `json:"product_sku_id"`
	ProductName        string      `json:"product_name"`
	Sku                string      `json:"sku"`
	VariantDescription pgtype.Text `json:"variant_description"`
	Quantity           int32       `json:"quantity"`
	QuantityDispatched int32       `json:"quantity_dispatched"`
	QuantityRemaining  int32       `json:"quantity_remaining"`
}

// Get order items that still need to be shipped
func (q *Queries) GetUnfulfilledOrderItems(ctx context.Context, orderID pgtype.UUID) ([]GetUnfulfilledOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getUnfulfilledOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnfulfilledOrderItemsRow{}
	for rows.Next() {
		var i GetUnfulfilledOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductSkuID,
			&i.ProductName,
			&i.Sku,
			&i.VariantDescription,
			&i.Quantity,
			&i.QuantityDispatched,
			&i.QuantityRemaining,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many

SELECT
    o.id,
    o.tenant_id,
    o.order_number,
    o.order_type,
    o.status,
    o.total_cents,
    o.currency,
    o.created_at,
    o.updated_at,
    u.email as customer_email,
    CONCAT(u.first_name, ' ', u.last_name) as customer_name,
    sa.address_line1 as shipping_address_line1,
    sa.city as shipping_city,
    sa.state as shipping_state
FROM orders o
LEFT JOIN users u ON u.id = o.user_id
LEFT JOIN addresses sa ON sa.id = o.shipping_address_id
WHERE o.tenant_id = $1
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListOrdersRow struct {
	ID                   pgtype.UUID        `json:"id"`
	TenantID             pgtype.UUID        `json:"tenant_id"`
	OrderNumber          string             `json:"order_number"`
	OrderType            string             `json:"order_type"`
	Status               string             `json:"status"`
	TotalCents           int32              `json:"total_cents"`
	Currency             string             `json:"currency"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CustomerEmail        pgtype.Text        `json:"customer_email"`
	CustomerName         interface{}        `json:"customer_name"`
	ShippingAddressLine1 pgtype.Text        `json:"shipping_address_line1"`
	ShippingCity         pgtype.Text        `json:"shipping_city"`
	ShippingState        pgtype.Text        `json:"shipping_state"`
}

// Admin queries
// List all orders for admin with pagination
func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.OrderType,
			&i.Status,
			&i.TotalCents,
			&i.Currency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.ShippingAddressLine1,
			&i.ShippingCity,
			&i.ShippingState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByStatus = `-- name: ListOrdersByStatus :many
SELECT
    o.id,
    o.tenant_id,
    o.order_number,
    o.order_type,
    o.status,
    o.total_cents,
    o.currency,
    o.created_at,
    u.email as customer_email,
    CONCAT(u.first_name, ' ', u.last_name) as customer_name
FROM orders o
LEFT JOIN users u ON u.id = o.user_id
WHERE o.tenant_id = $1
  AND o.status = $2
ORDER BY o.created_at DESC
`

type ListOrdersByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   string      `json:"status"`
}

type ListOrdersByStatusRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	OrderNumber   string             `json:"order_number"`
	OrderType     string             `json:"order_type"`
	Status        string             `json:"status"`
	TotalCents    int32              `json:"total_cents"`
	Currency      string             `json:"currency"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CustomerEmail pgtype.Text        `json:"customer_email"`
	CustomerName  interface{}        `json:"customer_name"`
}

// List orders filtered by status
func (q *Queries) ListOrdersByStatus(ctx context.Context, arg ListOrdersByStatusParams) ([]ListOrdersByStatusRow, error) {
	rows, err := q.db.Query(ctx, listOrdersByStatus, arg.TenantID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersByStatusRow{}
	for rows.Next() {
		var i ListOrdersByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.OrderType,
			&i.Status,
			&i.TotalCents,
			&i.Currency,
			&i.CreatedAt,
			&i.CustomerEmail,
			&i.CustomerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersBySubscription = `-- name: ListOrdersBySubscription :many
SELECT
    o.id,
    o.tenant_id,
    o.order_number,
    o.order_type,
    o.status,
    o.total_cents,
    o.currency,
    o.fulfillment_status,
    o.created_at,
    p.status as payment_status
FROM orders o
LEFT JOIN payments p ON p.id = o.payment_id
WHERE o.tenant_id = $1
  AND o.subscription_id = $2
ORDER BY o.created_at DESC
`

type ListOrdersBySubscriptionParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
}

type ListOrdersBySubscriptionRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	OrderNumber       string             `json:"order_number"`
	OrderType         string             `json:"order_type"`
	Status            string             `json:"status"`
	TotalCents        int32              `json:"total_cents"`
	Currency          string             `json:"currency"`
	FulfillmentStatus string             `json:"fulfillment_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	PaymentStatus     pgtype.Text        `json:"payment_status"`
}

// Get all orders for a specific subscription
// Used by subscription detail page to show order history
func (q *Queries) ListOrdersBySubscription(ctx context.Context, arg ListOrdersBySubscriptionParams) ([]ListOrdersBySubscriptionRow, error) {
	rows, err := q.db.Query(ctx, listOrdersBySubscription, arg.TenantID, arg.SubscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersBySubscriptionRow{}
	for rows.Next() {
		var i ListOrdersBySubscriptionRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.OrderType,
			&i.Status,
			&i.TotalCents,
			&i.Currency,
			&i.FulfillmentStatus,
			&i.CreatedAt,
			&i.PaymentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWholesaleOrders = `-- name: ListWholesaleOrders :many

SELECT
    o.id,
    o.tenant_id,
    o.order_number,
    o.order_type,
    o.status,
    o.fulfillment_status,
    o.total_cents,
    o.currency,
    o.customer_po_number,
    o.requested_delivery_date,
    o.created_at,
    u.email as customer_email,
    u.company_name,
    CONCAT(u.first_name, ' ', u.last_name) as customer_name
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE o.tenant_id = $1
  AND o.order_type = 'wholesale'
ORDER BY o.created_at DESC
LIMIT $2 OFFSET $3
`

type ListWholesaleOrdersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListWholesaleOrdersRow struct {
	ID                    pgtype.UUID        `json:"id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	OrderNumber           string             `json:"order_number"`
	OrderType             string             `json:"order_type"`
	Status                string             `json:"status"`
	FulfillmentStatus     string             `json:"fulfillment_status"`
	TotalCents            int32              `json:"total_cents"`
	Currency              string             `json:"currency"`
	CustomerPoNumber      pgtype.Text        `json:"customer_po_number"`
	RequestedDeliveryDate pgtype.Date        `json:"requested_delivery_date"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	CustomerEmail         string             `json:"customer_email"`
	CompanyName           pgtype.Text        `json:"company_name"`
	CustomerName          interface{}        `json:"customer_name"`
}

// =============================================================================
// WHOLESALE ORDER QUERIES
// =============================================================================
// List wholesale orders with customer details
func (q *Queries) ListWholesaleOrders(ctx context.Context, arg ListWholesaleOrdersParams) ([]ListWholesaleOrdersRow, error) {
	rows, err := q.db.Query(ctx, listWholesaleOrders, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWholesaleOrdersRow{}
	for rows.Next() {
		var i ListWholesaleOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.OrderType,
			&i.Status,
			&i.FulfillmentStatus,
			&i.TotalCents,
			&i.Currency,
			&i.CustomerPoNumber,
			&i.RequestedDeliveryDate,
			&i.CreatedAt,
			&i.CustomerEmail,
			&i.CompanyName,
			&i.CustomerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateOrderFulfillmentStatus = `-- name: RecalculateOrderFulfillmentStatus :exec
UPDATE orders
SET
    fulfillment_status = (
        SELECT CASE
            WHEN COUNT(*) FILTER (WHERE oi.quantity_dispatched < oi.quantity) = 0 THEN 'fulfilled'
            WHEN COUNT(*) FILTER (WHERE oi.quantity_dispatched > 0) > 0 THEN 'partial'
            ELSE 'unfulfilled'
        END
        FROM order_items oi
        WHERE oi.order_id = orders.id
    ),
    updated_at = NOW()
WHERE orders.tenant_id = $1
  AND orders.id = $2
`

type RecalculateOrderFulfillmentStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

// Update order fulfillment status based on item statuses
func (q *Queries) RecalculateOrderFulfillmentStatus(ctx context.Context, arg RecalculateOrderFulfillmentStatusParams) error {
	_, err := q.db.Exec(ctx, recalculateOrderFulfillmentStatus, arg.TenantID, arg.ID)
	return err
}

const updateCartStatus = `-- name: UpdateCartStatus :exec

UPDATE carts
SET status = $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateCartStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
	Status   string      `json:"status"`
}

// Ensures sufficient stock
// Marks cart as converted to order
// Prevents duplicate order creation from same cart
func (q *Queries) UpdateCartStatus(ctx context.Context, arg UpdateCartStatusParams) error {
	_, err := q.db.Exec(ctx, updateCartStatus, arg.TenantID, arg.ID, arg.Status)
	return err
}

const updateOrderFulfillmentStatus = `-- name: UpdateOrderFulfillmentStatus :exec
UPDATE orders
SET
    fulfillment_status = $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateOrderFulfillmentStatusParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	ID                pgtype.UUID `json:"id"`
	FulfillmentStatus string      `json:"fulfillment_status"`
}

// Update order fulfillment status
func (q *Queries) UpdateOrderFulfillmentStatus(ctx context.Context, arg UpdateOrderFulfillmentStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderFulfillmentStatus, arg.TenantID, arg.ID, arg.FulfillmentStatus)
	return err
}

const updateOrderItemDispatchedQuantity = `-- name: UpdateOrderItemDispatchedQuantity :exec

UPDATE order_items
SET
    quantity_dispatched = quantity_dispatched + $3,
    fulfillment_status = CASE
        WHEN quantity_dispatched + $3 >= quantity THEN 'fulfilled'
        ELSE fulfillment_status
    END,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateOrderItemDispatchedQuantityParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	ID                 pgtype.UUID `json:"id"`
	QuantityDispatched int32       `json:"quantity_dispatched"`
}

// =============================================================================
// PARTIAL FULFILLMENT QUERIES
// =============================================================================
// Update the dispatched quantity for an order item
func (q *Queries) UpdateOrderItemDispatchedQuantity(ctx context.Context, arg UpdateOrderItemDispatchedQuantityParams) error {
	_, err := q.db.Exec(ctx, updateOrderItemDispatchedQuantity, arg.TenantID, arg.ID, arg.QuantityDispatched)
	return err
}

const updateOrderPaymentID = `-- name: UpdateOrderPaymentID :exec
UPDATE orders
SET payment_id = $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateOrderPaymentIDParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ID        pgtype.UUID `json:"id"`
	PaymentID pgtype.UUID `json:"payment_id"`
}

// Links a payment to an order after both are created
func (q *Queries) UpdateOrderPaymentID(ctx context.Context, arg UpdateOrderPaymentIDParams) error {
	_, err := q.db.Exec(ctx, updateOrderPaymentID, arg.TenantID, arg.ID, arg.PaymentID)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET
    status = $3,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateOrderStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
	Status   string      `json:"status"`
}

// Update order status
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.TenantID, arg.ID, arg.Status)
	return err
}

const updateShipmentStatus = `-- name: UpdateShipmentStatus :exec
UPDATE shipments
SET
    status = $3,
    shipped_at = CASE WHEN $3 = 'shipped' THEN NOW() ELSE shipped_at END,
    delivered_at = CASE WHEN $3 = 'delivered' THEN NOW() ELSE delivered_at END,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
`

type UpdateShipmentStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
	Status   string      `json:"status"`
}

// Update shipment status
func (q *Queries) UpdateShipmentStatus(ctx context.Context, arg UpdateShipmentStatusParams) error {
	_, err := q.db.Exec(ctx, updateShipmentStatus, arg.TenantID, arg.ID, arg.Status)
	return err
}
