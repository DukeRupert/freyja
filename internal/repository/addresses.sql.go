// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: addresses.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAddress = `-- name: CreateAddress :one
INSERT INTO addresses (
    tenant_id,
    full_name,
    company,
    address_line1,
    address_line2,
    city,
    state,
    postal_code,
    country,
    phone,
    email,
    address_type
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, tenant_id, full_name, company, address_line1, address_line2, city, state, postal_code, country, phone, email, address_type, is_validated, validation_metadata, created_at, updated_at
`

type CreateAddressParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	FullName     pgtype.Text `json:"full_name"`
	Company      pgtype.Text `json:"company"`
	AddressLine1 string      `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
	City         string      `json:"city"`
	State        string      `json:"state"`
	PostalCode   string      `json:"postal_code"`
	Country      string      `json:"country"`
	Phone        pgtype.Text `json:"phone"`
	Email        pgtype.Text `json:"email"`
	AddressType  string      `json:"address_type"`
}

// Create a new address
func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, createAddress,
		arg.TenantID,
		arg.FullName,
		arg.Company,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
		arg.Email,
		arg.AddressType,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.AddressType,
		&i.IsValidated,
		&i.ValidationMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCustomerAddress = `-- name: CreateCustomerAddress :one
INSERT INTO customer_addresses (
    tenant_id,
    user_id,
    address_id,
    is_default_shipping,
    is_default_billing,
    label
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, user_id, address_id, is_default_shipping, is_default_billing, label, created_at
`

type CreateCustomerAddressParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	UserID            pgtype.UUID `json:"user_id"`
	AddressID         pgtype.UUID `json:"address_id"`
	IsDefaultShipping bool        `json:"is_default_shipping"`
	IsDefaultBilling  bool        `json:"is_default_billing"`
	Label             pgtype.Text `json:"label"`
}

// Link an address to a user
func (q *Queries) CreateCustomerAddress(ctx context.Context, arg CreateCustomerAddressParams) (CustomerAddress, error) {
	row := q.db.QueryRow(ctx, createCustomerAddress,
		arg.TenantID,
		arg.UserID,
		arg.AddressID,
		arg.IsDefaultShipping,
		arg.IsDefaultBilling,
		arg.Label,
	)
	var i CustomerAddress
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.AddressID,
		&i.IsDefaultShipping,
		&i.IsDefaultBilling,
		&i.Label,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCustomerAddress = `-- name: DeleteCustomerAddress :exec
DELETE FROM customer_addresses
WHERE tenant_id = $1
  AND user_id = $2
  AND address_id = $3
`

type DeleteCustomerAddressParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	UserID    pgtype.UUID `json:"user_id"`
	AddressID pgtype.UUID `json:"address_id"`
}

// Remove association between user and address
func (q *Queries) DeleteCustomerAddress(ctx context.Context, arg DeleteCustomerAddressParams) error {
	_, err := q.db.Exec(ctx, deleteCustomerAddress, arg.TenantID, arg.UserID, arg.AddressID)
	return err
}

const getAddressByID = `-- name: GetAddressByID :one
SELECT id, tenant_id, full_name, company, address_line1, address_line2, city, state, postal_code, country, phone, email, address_type, is_validated, validation_metadata, created_at, updated_at FROM addresses
WHERE id = $1
LIMIT 1
`

// Get a single address by ID (no user validation - for system use)
func (q *Queries) GetAddressByID(ctx context.Context, id pgtype.UUID) (Address, error) {
	row := q.db.QueryRow(ctx, getAddressByID, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.AddressType,
		&i.IsValidated,
		&i.ValidationMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAddressByIDForUser = `-- name: GetAddressByIDForUser :one
SELECT
    a.id,
    a.tenant_id,
    a.full_name,
    a.company,
    a.address_line1,
    a.address_line2,
    a.city,
    a.state,
    a.postal_code,
    a.country,
    a.phone,
    a.email,
    a.address_type,
    a.is_validated,
    a.created_at,
    a.updated_at
FROM addresses a
INNER JOIN customer_addresses ca ON ca.address_id = a.id
WHERE a.id = $1
  AND ca.tenant_id = $2
  AND ca.user_id = $3
LIMIT 1
`

type GetAddressByIDForUserParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type GetAddressByIDForUserRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	FullName     pgtype.Text        `json:"full_name"`
	Company      pgtype.Text        `json:"company"`
	AddressLine1 string             `json:"address_line1"`
	AddressLine2 pgtype.Text        `json:"address_line2"`
	City         string             `json:"city"`
	State        string             `json:"state"`
	PostalCode   string             `json:"postal_code"`
	Country      string             `json:"country"`
	Phone        pgtype.Text        `json:"phone"`
	Email        pgtype.Text        `json:"email"`
	AddressType  string             `json:"address_type"`
	IsValidated  bool               `json:"is_validated"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Get a single address by ID (validates user ownership via customer_addresses)
func (q *Queries) GetAddressByIDForUser(ctx context.Context, arg GetAddressByIDForUserParams) (GetAddressByIDForUserRow, error) {
	row := q.db.QueryRow(ctx, getAddressByIDForUser, arg.ID, arg.TenantID, arg.UserID)
	var i GetAddressByIDForUserRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.AddressType,
		&i.IsValidated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDefaultShippingAddress = `-- name: GetDefaultShippingAddress :one
SELECT
    a.id,
    a.tenant_id,
    a.full_name,
    a.company,
    a.address_line1,
    a.address_line2,
    a.city,
    a.state,
    a.postal_code,
    a.country,
    a.phone,
    a.email,
    a.address_type,
    a.is_validated,
    a.created_at,
    a.updated_at
FROM addresses a
INNER JOIN customer_addresses ca ON ca.address_id = a.id
WHERE ca.tenant_id = $1
  AND ca.user_id = $2
  AND ca.is_default_shipping = TRUE
LIMIT 1
`

type GetDefaultShippingAddressParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type GetDefaultShippingAddressRow struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	FullName     pgtype.Text        `json:"full_name"`
	Company      pgtype.Text        `json:"company"`
	AddressLine1 string             `json:"address_line1"`
	AddressLine2 pgtype.Text        `json:"address_line2"`
	City         string             `json:"city"`
	State        string             `json:"state"`
	PostalCode   string             `json:"postal_code"`
	Country      string             `json:"country"`
	Phone        pgtype.Text        `json:"phone"`
	Email        pgtype.Text        `json:"email"`
	AddressType  string             `json:"address_type"`
	IsValidated  bool               `json:"is_validated"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Get the default shipping address for a user
func (q *Queries) GetDefaultShippingAddress(ctx context.Context, arg GetDefaultShippingAddressParams) (GetDefaultShippingAddressRow, error) {
	row := q.db.QueryRow(ctx, getDefaultShippingAddress, arg.TenantID, arg.UserID)
	var i GetDefaultShippingAddressRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.AddressType,
		&i.IsValidated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAddressesForUser = `-- name: ListAddressesForUser :many
SELECT
    a.id,
    a.tenant_id,
    a.full_name,
    a.company,
    a.address_line1,
    a.address_line2,
    a.city,
    a.state,
    a.postal_code,
    a.country,
    a.phone,
    a.email,
    a.address_type,
    a.is_validated,
    a.created_at,
    a.updated_at,
    ca.is_default_shipping,
    ca.is_default_billing,
    ca.label
FROM addresses a
INNER JOIN customer_addresses ca ON ca.address_id = a.id
WHERE ca.tenant_id = $1
  AND ca.user_id = $2
ORDER BY ca.is_default_shipping DESC, a.created_at DESC
`

type ListAddressesForUserParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type ListAddressesForUserRow struct {
	ID                pgtype.UUID        `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	FullName          pgtype.Text        `json:"full_name"`
	Company           pgtype.Text        `json:"company"`
	AddressLine1      string             `json:"address_line1"`
	AddressLine2      pgtype.Text        `json:"address_line2"`
	City              string             `json:"city"`
	State             string             `json:"state"`
	PostalCode        string             `json:"postal_code"`
	Country           string             `json:"country"`
	Phone             pgtype.Text        `json:"phone"`
	Email             pgtype.Text        `json:"email"`
	AddressType       string             `json:"address_type"`
	IsValidated       bool               `json:"is_validated"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	IsDefaultShipping bool               `json:"is_default_shipping"`
	IsDefaultBilling  bool               `json:"is_default_billing"`
	Label             pgtype.Text        `json:"label"`
}

// Get all addresses for a user with their associations
func (q *Queries) ListAddressesForUser(ctx context.Context, arg ListAddressesForUserParams) ([]ListAddressesForUserRow, error) {
	rows, err := q.db.Query(ctx, listAddressesForUser, arg.TenantID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAddressesForUserRow{}
	for rows.Next() {
		var i ListAddressesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FullName,
			&i.Company,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Email,
			&i.AddressType,
			&i.IsValidated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDefaultShipping,
			&i.IsDefaultBilling,
			&i.Label,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultShippingAddress = `-- name: SetDefaultShippingAddress :exec
UPDATE customer_addresses
SET is_default_shipping = (address_id = $3)
WHERE tenant_id = $1
  AND user_id = $2
`

type SetDefaultShippingAddressParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	UserID    pgtype.UUID `json:"user_id"`
	AddressID pgtype.UUID `json:"address_id"`
}

// Set an address as the default shipping address for a user
func (q *Queries) SetDefaultShippingAddress(ctx context.Context, arg SetDefaultShippingAddressParams) error {
	_, err := q.db.Exec(ctx, setDefaultShippingAddress, arg.TenantID, arg.UserID, arg.AddressID)
	return err
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET
    full_name = $3,
    company = $4,
    address_line1 = $5,
    address_line2 = $6,
    city = $7,
    state = $8,
    postal_code = $9,
    country = $10,
    phone = $11,
    email = $12,
    updated_at = NOW()
WHERE tenant_id = $1
  AND id = $2
RETURNING id, tenant_id, full_name, company, address_line1, address_line2, city, state, postal_code, country, phone, email, address_type, is_validated, validation_metadata, created_at, updated_at
`

type UpdateAddressParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	ID           pgtype.UUID `json:"id"`
	FullName     pgtype.Text `json:"full_name"`
	Company      pgtype.Text `json:"company"`
	AddressLine1 string      `json:"address_line1"`
	AddressLine2 pgtype.Text `json:"address_line2"`
	City         string      `json:"city"`
	State        string      `json:"state"`
	PostalCode   string      `json:"postal_code"`
	Country      string      `json:"country"`
	Phone        pgtype.Text `json:"phone"`
	Email        pgtype.Text `json:"email"`
}

// Update an address
func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.TenantID,
		arg.ID,
		arg.FullName,
		arg.Company,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
		arg.Email,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FullName,
		&i.Company,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.AddressType,
		&i.IsValidated,
		&i.ValidationMetadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
