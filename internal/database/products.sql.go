// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateProduct = `-- name: ActivateProduct :one
UPDATE products
SET
  active = true,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

func (q *Queries) ActivateProduct(ctx context.Context, id int32) (Products, error) {
	row := q.db.QueryRow(ctx, activateProduct, id)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name, description, price, stock, active
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

type CreateProductParams struct {
	Name        string      `db:"name" json:"name"`
	Description pgtype.Text `db:"description" json:"description"`
	Price       int32       `db:"price" json:"price"`
	Stock       int32       `db:"stock" json:"stock"`
	Active      bool        `db:"active" json:"active"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Products, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Stock,
		arg.Active,
	)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateProduct = `-- name: DeactivateProduct :one
UPDATE products
SET
  active = false,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

func (q *Queries) DeactivateProduct(ctx context.Context, id int32) (Products, error) {
	row := q.db.QueryRow(ctx, deactivateProduct, id)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementProductStock = `-- name: DecrementProductStock :one
UPDATE products
SET
  stock = stock - $2,
  updated_at = NOW()
WHERE id = $1 AND stock >= $2
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

type DecrementProductStockParams struct {
	ID    int32 `db:"id" json:"id"`
	Stock int32 `db:"stock" json:"stock"`
}

func (q *Queries) DecrementProductStock(ctx context.Context, arg DecrementProductStockParams) (Products, error) {
	row := q.db.QueryRow(ctx, decrementProductStock, arg.ID, arg.Stock)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE active = true AND stock <= $1
ORDER BY stock ASC
`

func (q *Queries) GetLowStockProducts(ctx context.Context, stock int32) ([]Products, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts, stock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one

SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE id = $1
`

// internal/database/queries/products.sql
func (q *Queries) GetProduct(ctx context.Context, id int32) (Products, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByName = `-- name: GetProductByName :one
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE name = $1
`

func (q *Queries) GetProductByName(ctx context.Context, name string) (Products, error) {
	row := q.db.QueryRow(ctx, getProductByName, name)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductCount = `-- name: GetProductCount :one
SELECT COUNT(*) FROM products WHERE active = $1
`

func (q *Queries) GetProductCount(ctx context.Context, active bool) (int64, error) {
	row := q.db.QueryRow(ctx, getProductCount, active)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProductsInStock = `-- name: GetProductsInStock :many
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE active = true AND stock > 0
ORDER BY stock DESC
`

func (q *Queries) GetProductsInStock(ctx context.Context) ([]Products, error) {
	rows, err := q.db.Query(ctx, getProductsInStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalProductValue = `-- name: GetTotalProductValue :one
SELECT COALESCE(SUM(price * stock), 0)::integer as total_value
FROM products
WHERE active = true
`

func (q *Queries) GetTotalProductValue(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalProductValue)
	var total_value int32
	err := row.Scan(&total_value)
	return total_value, err
}

const incrementProductStock = `-- name: IncrementProductStock :one
UPDATE products
SET
  stock = stock + $2,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

type IncrementProductStockParams struct {
	ID    int32 `db:"id" json:"id"`
	Stock int32 `db:"stock" json:"stock"`
}

func (q *Queries) IncrementProductStock(ctx context.Context, arg IncrementProductStockParams) (Products, error) {
	row := q.db.QueryRow(ctx, incrementProductStock, arg.ID, arg.Stock)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllProducts = `-- name: ListAllProducts :many
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllProductsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListAllProducts(ctx context.Context, arg ListAllProductsParams) ([]Products, error) {
	rows, err := q.db.Query(ctx, listAllProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE active = true
ORDER BY name
`

func (q *Queries) ListProducts(ctx context.Context) ([]Products, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByStatus = `-- name: ListProductsByStatus :many
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE active = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListProductsByStatusParams struct {
	Active bool  `db:"active" json:"active"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListProductsByStatus(ctx context.Context, arg ListProductsByStatusParams) ([]Products, error) {
	rows, err := q.db.Query(ctx, listProductsByStatus, arg.Active, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, description, price, stock, active, created_at, updated_at
FROM products
WHERE active = true
  AND (name ILIKE $1 OR description ILIKE $1)
ORDER BY
  CASE WHEN name ILIKE $1 THEN 1 ELSE 2 END,
  name
`

func (q *Queries) SearchProducts(ctx context.Context, name string) ([]Products, error) {
	rows, err := q.db.Query(ctx, searchProducts, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
  name = $2,
  description = $3,
  price = $4,
  stock = $5,
  active = $6,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

type UpdateProductParams struct {
	ID          int32       `db:"id" json:"id"`
	Name        string      `db:"name" json:"name"`
	Description pgtype.Text `db:"description" json:"description"`
	Price       int32       `db:"price" json:"price"`
	Stock       int32       `db:"stock" json:"stock"`
	Active      bool        `db:"active" json:"active"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Products, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Stock,
		arg.Active,
	)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductPrice = `-- name: UpdateProductPrice :one
UPDATE products
SET
  price = $2,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

type UpdateProductPriceParams struct {
	ID    int32 `db:"id" json:"id"`
	Price int32 `db:"price" json:"price"`
}

func (q *Queries) UpdateProductPrice(ctx context.Context, arg UpdateProductPriceParams) (Products, error) {
	row := q.db.QueryRow(ctx, updateProductPrice, arg.ID, arg.Price)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductStock = `-- name: UpdateProductStock :one
UPDATE products
SET
  stock = $2,
  updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, active, created_at, updated_at
`

type UpdateProductStockParams struct {
	ID    int32 `db:"id" json:"id"`
	Stock int32 `db:"stock" json:"stock"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) (Products, error) {
	row := q.db.QueryRow(ctx, updateProductStock, arg.ID, arg.Stock)
	var i Products
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
